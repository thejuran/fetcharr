---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - fetcharr/__init__.py
  - fetcharr/models/__init__.py
  - fetcharr/models/config.py
  - fetcharr/config.py
  - fetcharr/logging.py
  - fetcharr/state.py
  - fetcharr/clients/__init__.py
autonomous: true
requirements:
  - CONN-01
  - CONN-02
  - SECR-01

must_haves:
  truths:
    - "Settings load from /config/fetcharr.toml with [general], [radarr], [sonarr] sections"
    - "API keys are stored as SecretStr and never appear in string representations"
    - "Loguru redaction filter strips any configured API key value from all log output"
    - "State file writes atomically via write-then-rename pattern"
    - "Config models validate that at least one app has a non-empty URL when enabled"
  artifacts:
    - path: "pyproject.toml"
      provides: "Project metadata and dependencies"
      contains: "pydantic-settings"
    - path: "fetcharr/models/config.py"
      provides: "ArrConfig and Settings Pydantic models with SecretStr api_key"
      contains: "SecretStr"
    - path: "fetcharr/config.py"
      provides: "TOML config loading and default config generation"
      contains: "TomlConfigSettingsSource"
    - path: "fetcharr/logging.py"
      provides: "Loguru setup with redaction filter"
      contains: "create_redaction_filter"
    - path: "fetcharr/state.py"
      provides: "Atomic JSON state persistence"
      contains: "os.replace"
  key_links:
    - from: "fetcharr/config.py"
      to: "fetcharr/models/config.py"
      via: "imports Settings model"
      pattern: "from fetcharr\\.models\\.config import"
    - from: "fetcharr/logging.py"
      to: "fetcharr/models/config.py"
      via: "reads api_key SecretStr values for redaction list"
      pattern: "get_secret_value"
---

<objective>
Set up the Fetcharr Python package with project scaffolding, TOML configuration loading via pydantic-settings, loguru-based logging with API key redaction, and atomic JSON state persistence.

Purpose: Establish the foundational infrastructure that all other Phase 1 plans build on -- config models, logging, and state storage.
Output: A working Python package with config loading, secure logging, and state file I/O.
</objective>

<execution_context>
@/Users/julianamacbook/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julianamacbook/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create project scaffolding and Pydantic config models with TOML loading</name>
  <files>
    pyproject.toml
    fetcharr/__init__.py
    fetcharr/models/__init__.py
    fetcharr/models/config.py
    fetcharr/config.py
    fetcharr/clients/__init__.py
  </files>
  <action>
    1. Create `pyproject.toml` with project metadata:
       - name: "fetcharr", version: "0.1.0", requires-python: ">=3.11"
       - Dependencies: `pydantic-settings[toml]`, `httpx`, `loguru`, `tomli-w`, `fastapi`, `uvicorn[standard]`
       - Script entry point: `fetcharr = "fetcharr.__main__:main"`

    2. Create `fetcharr/__init__.py` with `__version__ = "0.1.0"`

    3. Create `fetcharr/models/__init__.py` (empty)

    4. Create `fetcharr/clients/__init__.py` (empty)

    5. Create `fetcharr/models/config.py` with Pydantic models:
       - `ArrConfig(BaseModel)`: `url: str = ""`, `api_key: SecretStr = SecretStr("")`, `enabled: bool = False`
       - `GeneralConfig(BaseModel)`: `log_level: str = "info"`
       - `Settings(BaseSettings)`: `general: GeneralConfig`, `radarr: ArrConfig`, `sonarr: ArrConfig`
       - Override `settings_customise_sources` to use ONLY `TomlConfigSettingsSource` pointing at the config file path
       - Config file path: use a module-level constant `CONFIG_PATH = Path("/config/fetcharr.toml")` that can be overridden for testing
       - Add a `@model_validator(mode="after")` on Settings that validates at least one app is enabled with a non-empty URL. Raise ValueError with clear message: "At least one app (radarr or sonarr) must be configured with a URL and enabled"

    6. Create `fetcharr/config.py` with:
       - `load_settings(config_path: Path) -> Settings`: Load and return Settings from TOML file. Accept path parameter to allow testing with custom paths.
       - `generate_default_config(config_path: Path) -> None`: Write commented default TOML config template using `tomli_w`. Use the DEFAULT_CONFIG template from RESEARCH.md. Ensure parent directories are created.
       - `ensure_config(config_path: Path) -> Settings`: Check if config file exists. If missing, call `generate_default_config()`, print message to stderr telling user to edit it, and call `sys.exit(1)`. If exists, call `load_settings()` and return.

    Important: API keys use `SecretStr` â€” this is the first security invariant. `SecretStr.__repr__` and `__str__` both return `**********`, preventing accidental exposure in any string formatting, logging, or serialization.
  </action>
  <verify>
    <automated>cd /Users/julianamacbook/fetcharr && python -c "
from fetcharr.models.config import ArrConfig, GeneralConfig, Settings
from pydantic import SecretStr
# Verify SecretStr hides value
ac = ArrConfig(url='http://test:7878', api_key=SecretStr('my-secret-key'), enabled=True)
assert 'my-secret-key' not in str(ac), 'API key leaked in str()'
assert 'my-secret-key' not in repr(ac), 'API key leaked in repr()'
assert ac.api_key.get_secret_value() == 'my-secret-key'
print('Config models OK')
"</automated>
  </verify>
  <done>
    - pyproject.toml exists with all dependencies listed
    - Settings model loads from TOML with [general], [radarr], [sonarr] sections
    - ArrConfig.api_key is SecretStr -- never appears in str/repr
    - Settings validator rejects config with no enabled apps
    - Default config template can be generated to disk
  </done>
</task>

<task type="auto">
  <name>Task 2: Set up loguru logging with API key redaction and atomic JSON state store</name>
  <files>
    fetcharr/logging.py
    fetcharr/state.py
  </files>
  <action>
    1. Create `fetcharr/logging.py`:
       - `create_redaction_filter(secrets: list[str]) -> Callable`: Returns a loguru filter function that replaces any occurrence of a secret string in `record["message"]` with `[REDACTED]`. Skip empty strings in the secrets list.
       - `setup_logging(level: str, secrets: list[str]) -> None`:
         - Call `logger.remove()` to remove the default stderr handler
         - Call `logger.add(sys.stderr, ...)` with:
           - format: `"{time:YYYY-MM-DD HH:mm:ss} {level:<8} {message}"`
           - level: `level.upper()`
           - filter: result of `create_redaction_filter(secrets)`
           - colorize: `True`
       - Log format matches user's locked decision: `2026-02-23 14:30:00 INFO     Connected to Radarr at http://radarr:7878`

    2. Create `fetcharr/state.py`:
       - `STATE_PATH = Path("/config/state.json")` (module-level default, overridable for testing)
       - Define state structure as a TypedDict or dataclass:
         ```python
         class AppState(TypedDict, total=False):
             missing_cursor: int
             cutoff_cursor: int
             last_run: str | None  # ISO timestamp
         ```
         ```python
         class FetcharrState(TypedDict, total=False):
             radarr: AppState
             sonarr: AppState
             search_log: list[dict]  # bounded log of recent searches
         ```
       - `load_state(state_path: Path) -> FetcharrState`: Read JSON file, return parsed dict. If file doesn't exist, return default empty state with both apps at cursor 0.
       - `save_state(state: FetcharrState, state_path: Path) -> None`: Atomic write using `tempfile.NamedTemporaryFile(mode="w", dir=parent, suffix=".tmp", delete=False)` + `json.dump` + `os.fsync` + `os.replace`. Ensure parent directory exists.
       - The atomic write pattern prevents corruption if the process crashes mid-write (locked user decision).
  </action>
  <verify>
    <automated>cd /Users/julianamacbook/fetcharr && python -c "
from fetcharr.logging import setup_logging, create_redaction_filter
from loguru import logger
import sys, io

# Test redaction
buf = io.StringIO()
logger.remove()
secrets = ['super-secret-key-123']
logger.add(buf, format='{message}', filter=create_redaction_filter(secrets))
logger.info('Testing key super-secret-key-123 in message')
output = buf.getvalue()
assert 'super-secret-key-123' not in output, f'Secret leaked: {output}'
assert '[REDACTED]' in output, f'Redaction missing: {output}'
print('Logging redaction OK')

# Test state
import tempfile, os
from pathlib import Path
from fetcharr.state import load_state, save_state
with tempfile.TemporaryDirectory() as td:
    sp = Path(td) / 'state.json'
    state = load_state(sp)
    assert state is not None
    state['radarr'] = {'missing_cursor': 5, 'cutoff_cursor': 3}
    save_state(state, sp)
    loaded = load_state(sp)
    assert loaded['radarr']['missing_cursor'] == 5
    print('State store OK')
"</automated>
  </verify>
  <done>
    - Loguru configured with human-readable format matching locked decision
    - Redaction filter strips API key values from ALL log output -- complete absence, not masking
    - State file loads and saves with atomic write-then-rename pattern
    - Missing state file returns sensible defaults (cursors at 0)
    - State survives a round-trip (save then load)
  </done>
</task>

</tasks>

<verification>
1. `python -c "from fetcharr.models.config import Settings; print('Config OK')"` -- imports succeed
2. `python -c "from fetcharr.logging import setup_logging; print('Logging OK')"` -- imports succeed
3. `python -c "from fetcharr.state import load_state, save_state; print('State OK')"` -- imports succeed
4. SecretStr prevents API key from appearing in any string representation
5. Loguru redaction filter removes API key values from log messages
6. State file atomic write uses os.replace pattern
</verification>

<success_criteria>
- All fetcharr package modules importable without error
- Pydantic Settings model validates TOML config with SecretStr api_key fields
- Loguru redaction filter provably strips secret values from log output
- State file persists and loads with atomic write pattern
- pyproject.toml lists all required dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
