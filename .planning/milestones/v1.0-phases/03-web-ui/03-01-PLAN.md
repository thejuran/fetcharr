---
phase: 03-web-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - fetcharr/web/__init__.py
  - fetcharr/web/routes.py
  - fetcharr/search/scheduler.py
  - fetcharr/__main__.py
  - fetcharr/templates/base.html
  - fetcharr/templates/dashboard.html
  - fetcharr/templates/settings.html
  - fetcharr/templates/partials/app_card.html
  - fetcharr/templates/partials/search_log.html
  - fetcharr/static/css/input.css
  - fetcharr/static/css/output.css
autonomous: true
requirements: []

must_haves:
  truths:
    - "Jinja2 and aiofiles are installed as production dependencies"
    - "pytailwindcss is installed as a dev dependency"
    - "FastAPI app mounts /static for CSS and includes the web router"
    - "Lifespan exposes fetcharr_state, settings, scheduler, clients, config_path, and state_path on app.state"
    - "Job closures read client and settings from app.state (not captured variables) for hot-reload readiness"
    - "make_search_job factory creates job functions that read from app.state"
    - "GET / returns the dashboard page with htmx polling containers (hx-trigger every 5s)"
    - "GET /partials/app-card/{app_name} returns an HTML fragment with app status"
    - "GET /partials/search-log returns an HTML fragment with recent search entries"
    - "GET /settings returns a placeholder settings page"
    - "htmx 2.0.8 loaded from CDN in base template"
    - "Dark mode only with green accent per user decision"
    - "Tailwind CSS v4 input file uses @import tailwindcss with custom theme"
  artifacts:
    - path: "fetcharr/web/routes.py"
      provides: "FastAPI router with dashboard, settings, and partial routes"
      contains: "APIRouter"
    - path: "fetcharr/templates/base.html"
      provides: "Base HTML layout with nav, htmx CDN script, Tailwind CSS"
      contains: "htmx.org"
    - path: "fetcharr/templates/dashboard.html"
      provides: "Dashboard page extending base with htmx polling containers"
      contains: "hx-trigger"
    - path: "fetcharr/search/scheduler.py"
      provides: "Modified lifespan with app.state exposure and make_search_job factory"
      contains: "app.state"
    - path: "fetcharr/static/css/input.css"
      provides: "Tailwind CSS source with custom dark theme"
      contains: "@import"
  key_links:
    - from: "fetcharr/web/routes.py"
      to: "fetcharr/search/scheduler.py"
      via: "Routes access state via request.app.state set by lifespan"
      pattern: "request.app.state"
    - from: "fetcharr/__main__.py"
      to: "fetcharr/web/routes.py"
      via: "App includes web router and mounts static files"
      pattern: "include_router"
    - from: "fetcharr/search/scheduler.py"
      to: "fetcharr/search/engine.py"
      via: "make_search_job delegates to run_radarr_cycle/run_sonarr_cycle"
      pattern: "run_radarr_cycle|run_sonarr_cycle"
---

<objective>
Install web dependencies, create the web module with route handlers, modify the scheduler lifespan to expose shared state on app.state, update the entry point to mount static files and include the router, and create the base templates with htmx polling infrastructure and Tailwind CSS dark theme.

Purpose: Establish the entire web UI infrastructure so that the dashboard page works end-to-end with htmx polling, rendering whatever state data is currently available (last_run, next_run, cursors, search_log). Subsequent plans add richer data sources and write operations.

Output: A working dashboard accessible at http://localhost:8080 that shows app status cards with 5-second htmx polling, a search log, and a nav bar linking to Dashboard and Settings pages.
</objective>

<execution_context>
@/Users/julianamacbook/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julianamacbook/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-web-ui/03-CONTEXT.md
@.planning/phases/03-web-ui/03-RESEARCH.md
@fetcharr/search/scheduler.py
@fetcharr/__main__.py
@fetcharr/models/config.py
@fetcharr/state.py
@fetcharr/search/engine.py
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dependencies, create web module, modify lifespan and entry point</name>
  <files>
    pyproject.toml
    fetcharr/web/__init__.py
    fetcharr/web/routes.py
    fetcharr/search/scheduler.py
    fetcharr/__main__.py
  </files>
  <action>
    **Add dependencies (pyproject.toml):**
    Add `"jinja2"` and `"aiofiles"` to the `dependencies` list. Add `"pytailwindcss"` to the `[project.optional-dependencies] dev` list.

    **Create fetcharr/web/__init__.py:**
    Empty package marker file.

    **Create fetcharr/web/routes.py:**
    ```python
    from pathlib import Path
    from fastapi import APIRouter, Request
    from fastapi.responses import HTMLResponse
    from fastapi.templating import Jinja2Templates

    _PKG_DIR = Path(__file__).resolve().parent.parent
    TEMPLATES_DIR = _PKG_DIR / "templates"
    STATIC_DIR = _PKG_DIR / "static"

    templates = Jinja2Templates(directory=str(TEMPLATES_DIR))
    router = APIRouter()
    ```

    Route handlers:

    1. `GET /` (dashboard) — Build a list of enabled app dicts. For each enabled app (`radarr`, `sonarr`), read from `request.app.state`:
       - `name`: app name string
       - `last_run`: `state[name]["last_run"]` (ISO string or None)
       - `next_run`: `scheduler.get_job(f"{name}_search").next_run_time` — format as ISO string if not None, else None. Guard with `if job and job.next_run_time`.
       - `missing_cursor`: `state[name]["missing_cursor"]`
       - `cutoff_cursor`: `state[name]["cutoff_cursor"]`

       Return `templates.TemplateResponse(request=request, name="dashboard.html", context={"apps": apps, "search_log": state.get("search_log", [])})`.

    2. `GET /settings` — Return `templates.TemplateResponse(request=request, name="settings.html", context={})`. Placeholder for Plan 03.

    3. `GET /partials/app-card/{app_name}` — Build a single app dict (same fields as dashboard) for the given `app_name`. Return partial template `"partials/app_card.html"` with `context={"app": app_data}`. If app not enabled, return empty `HTMLResponse("")`.

    4. `GET /partials/search-log` — Return partial template `"partials/search_log.html"` with `context={"search_log": state.get("search_log", [])}`.

    Helper: Create a `_build_app_context(request, app_name)` function to DRY the app dict construction between the dashboard and partial routes. Returns a dict with the fields above, or None if app not enabled.

    **Rewrite fetcharr/search/scheduler.py:**
    Replace the current implementation with an `app.state`-based approach.

    Add a `make_search_job` function (NOT underscore-prefixed — exported for Plan 03):
    ```python
    def make_search_job(app: FastAPI, app_name: str, state_path: Path):
        """Create an async job function that reads client/state/settings from app.state."""
        cycle_fn = run_radarr_cycle if app_name == "radarr" else run_sonarr_cycle

        async def job():
            client = getattr(app.state, f"{app_name}_client", None)
            if client is None:
                return
            try:
                app.state.fetcharr_state = await cycle_fn(
                    client, app.state.fetcharr_state, app.state.settings,
                )
                save_state(app.state.fetcharr_state, state_path)
            except Exception as exc:
                logger.error(
                    "{app}: Unhandled error in search cycle -- {exc}",
                    app=app_name.title(), exc=exc,
                )

        return job
    ```

    Update `create_lifespan` signature to accept `config_path: Path` as a third parameter:
    ```python
    def create_lifespan(settings: Settings, state_path: Path, config_path: Path) -> callable:
    ```

    Inside the lifespan:
    1. Load state, create scheduler, create clients (same as before)
    2. **NEW:** Expose all shared objects on `app.state`:
       ```python
       app.state.fetcharr_state = state
       app.state.settings = settings
       app.state.scheduler = scheduler
       app.state.radarr_client = radarr_client
       app.state.sonarr_client = sonarr_client
       app.state.config_path = config_path
       app.state.state_path = state_path
       ```
    3. **CHANGED:** Use `make_search_job` factory instead of inline closures. Loop over `("radarr", "sonarr")`, check `getattr(settings, name).enabled`, create job with `make_search_job(app, name, state_path)`, add to scheduler with same pattern as before (interval, id, next_run_time=now).
    4. Start scheduler, yield, shutdown. In finally: `scheduler.shutdown(wait=False)`, then close clients by reading from `app.state` (they may have been replaced by config editor):
       ```python
       for name in ("radarr", "sonarr"):
           client = getattr(app.state, f"{name}_client", None)
           if client:
               await client.close()
       ```

    **Update fetcharr/__main__.py:**
    Add imports:
    ```python
    from fastapi.staticfiles import StaticFiles
    from fetcharr.models.config import CONFIG_PATH
    from fetcharr.web.routes import STATIC_DIR, router
    ```

    In `_run()`, after creating the FastAPI app:
    ```python
    app = FastAPI(lifespan=create_lifespan(settings, STATE_PATH, CONFIG_PATH))
    app.mount("/static", StaticFiles(directory=str(STATIC_DIR)), name="static")
    app.include_router(router)
    ```
    The rest (uvicorn config + serve) stays the same.
  </action>
  <verify>
    <automated>cd /Users/julianamacbook/fetcharr && python -c "
from fetcharr.web.routes import router, TEMPLATES_DIR, STATIC_DIR
from pathlib import Path
assert TEMPLATES_DIR.exists(), f'Templates dir missing: {TEMPLATES_DIR}'
assert STATIC_DIR.parent.exists(), f'Static parent missing'
print(f'Router routes: {len(router.routes)}')
assert len(router.routes) >= 4, 'Expected at least 4 routes'
print('Routes OK')

from fetcharr.search.scheduler import create_lifespan, make_search_job
import inspect
sig = inspect.signature(create_lifespan)
assert 'config_path' in sig.parameters, 'Missing config_path parameter'
print('Lifespan signature OK')
assert callable(make_search_job)
print('make_search_job OK')

print('ALL PASSED')
"</automated>
  </verify>
  <done>Web module created with 4 routes (dashboard, settings, 2 partials). Lifespan exposes all shared state on app.state. make_search_job factory enables dynamic job creation. Entry point mounts static files and includes router.</done>
</task>

<task type="auto">
  <name>Task 2: Create templates and static files with Tailwind CSS</name>
  <files>
    fetcharr/templates/base.html
    fetcharr/templates/dashboard.html
    fetcharr/templates/settings.html
    fetcharr/templates/partials/app_card.html
    fetcharr/templates/partials/search_log.html
    fetcharr/static/css/input.css
    fetcharr/static/css/output.css
  </files>
  <action>
    Create the directory structure first:
    ```
    mkdir -p fetcharr/templates/partials fetcharr/static/css
    ```

    **fetcharr/static/css/input.css:**
    ```css
    @import "tailwindcss";

    @theme {
      --color-fetcharr-green: #22c55e;
      --color-fetcharr-green-dark: #16a34a;
      --color-fetcharr-bg: #0f172a;
      --color-fetcharr-card: #1e293b;
      --color-fetcharr-border: #334155;
      --color-fetcharr-text: #e2e8f0;
      --color-fetcharr-muted: #94a3b8;
    }
    ```

    **fetcharr/templates/base.html:**
    Standard HTML5 document with:
    - `<link rel="stylesheet" href="{{ url_for('static', path='css/output.css') }}">`
    - `<script src="https://unpkg.com/htmx.org@2.0.8"></script>`
    - `<body>` with class `bg-fetcharr-bg text-fetcharr-text min-h-screen`
    - Nav bar: `bg-fetcharr-card border-b border-fetcharr-border`. Contains flex row with "Fetcharr" brand text (text-fetcharr-green font-bold text-xl) on the left, and "Dashboard" / "Settings" links on the right. Links use `text-fetcharr-muted hover:text-white`. Active link detection via Jinja2 `{% block %}` overrides.
    - `<main>` container: `max-w-5xl mx-auto px-6 py-6` wrapping `{% block content %}{% endblock %}`
    - `{% block title %}Fetcharr{% endblock %}` in the `<title>` tag

    **fetcharr/templates/dashboard.html:**
    Extends `base.html`. Sets nav_dashboard active. Content block contains:
    1. Grid container: `grid grid-cols-1 md:grid-cols-2 gap-4 mb-6`
    2. Inside grid: `{% for app in apps %}{% include "partials/app_card.html" %}{% endfor %}`
    3. Below grid: `{% include "partials/search_log.html" %}`

    If `apps` is empty (no enabled apps), show a message: "No apps configured. Visit Settings to add Radarr or Sonarr."

    **fetcharr/templates/partials/app_card.html:**
    A self-contained div that includes htmx attributes for polling:
    ```html
    <div id="{{ app.name }}-card"
         hx-get="/partials/app-card/{{ app.name }}"
         hx-trigger="every 5s"
         hx-swap="outerHTML"
         class="bg-fetcharr-card rounded-lg border border-fetcharr-border p-5">
    ```
    Card contents:
    - Header row: App name capitalized (text-lg font-semibold), styled with a colored left border (green = `border-l-4 border-l-fetcharr-green`)
    - Status grid (2 columns of label/value pairs):
      - "Last Run": Format `app.last_run` as human-readable. Show "Never" if None. Use a Jinja2 filter or inline logic to format the ISO timestamp.
      - "Next Run": Format `app.next_run` similarly. Show "—" if None.
      - "Missing Queue": `Position {{ app.missing_cursor }}`
      - "Cutoff Queue": `Position {{ app.cutoff_cursor }}`
    - Each label in `text-xs uppercase text-fetcharr-muted`, each value in `text-sm`
    - Placeholder row at bottom for future controls (Plan 02 adds counts/health, Plan 03 adds buttons)

    **fetcharr/templates/partials/search_log.html:**
    A self-contained div with htmx polling:
    ```html
    <div id="search-log"
         hx-get="/partials/search-log"
         hx-trigger="every 5s"
         hx-swap="outerHTML"
         class="bg-fetcharr-card rounded-lg border border-fetcharr-border p-5">
    ```
    Contents:
    - Header: "Search Log" (text-lg font-semibold mb-3)
    - If `search_log` is empty: "No searches yet." in muted text
    - Otherwise: A compact table or list showing recent entries (newest first — reverse the list with `search_log[::-1]`). Each entry shows:
      - App badge (small colored label: Radarr/Sonarr)
      - Item name
      - Queue type (missing/cutoff)
      - Timestamp (formatted)
    - Limit display to most recent 20 entries: `search_log[::-1][:20]`
    - Use `text-xs` or `text-sm` for dense display per user preference

    **fetcharr/templates/settings.html:**
    Extends `base.html`. Sets nav_settings active. Content block shows:
    - Header: "Settings"
    - Placeholder message: "Settings editor coming soon." in muted text
    - Plan 03 replaces this with the full config form.

    **Compile Tailwind CSS:**
    Install pytailwindcss if not already installed, then compile:
    ```bash
    pip install pytailwindcss
    cd /Users/julianamacbook/fetcharr
    tailwindcss -i fetcharr/static/css/input.css -o fetcharr/static/css/output.css --minify
    ```

    If `tailwindcss` binary is not available after pip install, use `python -m pytailwindcss` instead. The compiled output.css must exist for the static file serving to work.

    **IMPORTANT:** If Tailwind v4 compilation fails (e.g., pytailwindcss ships an older binary), fall back to creating a minimal output.css manually that includes the base Tailwind reset plus the custom properties. This ensures the app works visually even without full Tailwind compilation. The Dockerfile (Phase 4) handles production compilation.
  </action>
  <verify>
    <automated>cd /Users/julianamacbook/fetcharr && python -c "
from pathlib import Path
templates = Path('fetcharr/templates')
assert (templates / 'base.html').exists(), 'base.html missing'
assert (templates / 'dashboard.html').exists(), 'dashboard.html missing'
assert (templates / 'settings.html').exists(), 'settings.html missing'
assert (templates / 'partials' / 'app_card.html').exists(), 'app_card.html missing'
assert (templates / 'partials' / 'search_log.html').exists(), 'search_log.html missing'
print('All templates exist')

static = Path('fetcharr/static')
assert (static / 'css' / 'input.css').exists(), 'input.css missing'
assert (static / 'css' / 'output.css').exists(), 'output.css missing'
print('Static files exist')

# Check htmx is referenced in base template
base = (templates / 'base.html').read_text()
assert 'htmx.org' in base, 'htmx CDN missing from base.html'
assert 'output.css' in base, 'Tailwind CSS link missing from base.html'
print('Base template references OK')

# Check dashboard has htmx polling
dash = (templates / 'dashboard.html').read_text()
assert 'hx-trigger' in dash or 'app_card.html' in dash, 'Dashboard missing htmx or include'
print('Dashboard template OK')

# Check partials have hx-trigger
card = (templates / 'partials' / 'app_card.html').read_text()
assert 'hx-trigger' in card, 'App card missing hx-trigger'
assert 'every 5s' in card, 'App card missing 5s polling'
print('Partials OK')

print('ALL PASSED')
"</automated>
  </verify>
  <done>All templates created with dark theme, htmx polling on partials (5s interval), nav bar with Dashboard/Settings links. Tailwind CSS compiled with custom fetcharr color theme. Static files served via /static mount.</done>
</task>

</tasks>

<verification>
- `python -c "from fetcharr.web.routes import router"` imports without error
- `python -c "from fetcharr.search.scheduler import create_lifespan, make_search_job"` imports without error
- All 5 templates exist in fetcharr/templates/
- fetcharr/static/css/output.css exists (compiled Tailwind)
- Existing test suite still passes: `pytest tests/ -x`
</verification>

<success_criteria>
- Jinja2 and aiofiles added as production dependencies
- Web module exists with router containing 4+ route handlers
- Lifespan exposes all shared state on app.state for route access
- make_search_job factory creates app.state-reading job functions
- Job closures no longer capture settings/clients directly (hot-reload ready)
- Base template loads htmx 2.0.8 CDN and Tailwind CSS
- Dashboard page renders with htmx-polling app cards and search log
- Settings page renders placeholder content
- Tailwind CSS compiled with dark theme and green accent colors
- Existing Phase 2 tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-web-ui/03-01-SUMMARY.md`
</output>
