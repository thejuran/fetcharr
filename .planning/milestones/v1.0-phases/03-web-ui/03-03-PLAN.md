---
phase: 03-web-ui
plan: 03
type: execute
wave: 3
depends_on: [03-02]
files_modified:
  - fetcharr/web/routes.py
  - fetcharr/search/scheduler.py
  - fetcharr/templates/settings.html
  - fetcharr/templates/partials/app_card.html
  - fetcharr/static/css/output.css
  - tests/test_web.py
autonomous: true
requirements: [WEBU-05, WEBU-07, WEBU-08]

must_haves:
  truths:
    - "GET /settings renders a form pre-filled with current settings (URLs, intervals, batch sizes, enabled flags)"
    - "API key fields show placeholder text (********) when a key exists, never the actual value"
    - "POST /settings writes valid TOML to disk via tomli_w, reloads Settings, updates app.state.settings"
    - "POST /settings reschedules existing scheduler jobs when intervals change"
    - "POST /settings adds new scheduler jobs when a previously-disabled app is enabled"
    - "POST /settings removes scheduler jobs and closes clients when an app is disabled"
    - "POST /settings redirects to GET /settings (PRG pattern, 303 status)"
    - "POST /api/search-now/{app_name} triggers an immediate search cycle and returns the updated app card partial"
    - "Dashboard app cards include a Search Now button that POSTs via htmx"
    - "Test suite covers GET/POST settings, search-now, and API key masking"
  artifacts:
    - path: "fetcharr/web/routes.py"
      provides: "Settings GET/POST routes and search-now API endpoint"
      contains: "save_settings"
    - path: "fetcharr/templates/settings.html"
      provides: "Config editor form with masked API keys and per-app sections"
      contains: "api_key"
    - path: "fetcharr/templates/partials/app_card.html"
      provides: "Dashboard card with Search Now button"
      contains: "search-now"
    - path: "tests/test_web.py"
      provides: "Web route test suite"
      contains: "test_"
  key_links:
    - from: "fetcharr/web/routes.py"
      to: "fetcharr/config.py"
      via: "POST /settings reloads config via load_settings"
      pattern: "load_settings"
    - from: "fetcharr/web/routes.py"
      to: "fetcharr/search/scheduler.py"
      via: "POST /settings calls make_search_job for newly-enabled apps"
      pattern: "make_search_job"
    - from: "fetcharr/web/routes.py"
      to: "fetcharr/search/engine.py"
      via: "Search-now endpoint calls run_radarr_cycle/run_sonarr_cycle directly"
      pattern: "run_radarr_cycle|run_sonarr_cycle"
---

<objective>
Implement the config editor (GET with masked API keys, POST with TOML write and hot-reload), the search-now trigger, and dashboard interactive controls (Search Now button). Add a web test suite.

Purpose: Complete the web UI's write operations so users can edit all settings via the browser and trigger immediate searches. After this plan, the Phase 3 Web UI is feature-complete.

Output: Working settings page at /settings with a form for all config fields (API keys masked), hot-reload on save, and a Search Now button on each dashboard card. Test suite validates all web routes.
</objective>

<execution_context>
@/Users/julianamacbook/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julianamacbook/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-web-ui/03-CONTEXT.md
@.planning/phases/03-web-ui/03-RESEARCH.md
@.planning/phases/03-web-ui/03-01-SUMMARY.md
@.planning/phases/03-web-ui/03-02-SUMMARY.md
@fetcharr/web/routes.py
@fetcharr/search/scheduler.py
@fetcharr/search/engine.py
@fetcharr/config.py
@fetcharr/models/config.py
@fetcharr/state.py
@fetcharr/templates/settings.html
@fetcharr/templates/partials/app_card.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Config editor routes, settings template, hot-reload, and search-now endpoint</name>
  <files>
    fetcharr/web/routes.py
    fetcharr/search/scheduler.py
    fetcharr/templates/settings.html
    fetcharr/templates/partials/app_card.html
    fetcharr/static/css/output.css
  </files>
  <action>
    **Update fetcharr/web/routes.py — Replace GET /settings:**

    Build form context for each app:
    ```python
    @router.get("/settings", response_class=HTMLResponse)
    async def settings_page(request: Request):
        settings = request.app.state.settings
        apps = {}
        for name in ("radarr", "sonarr"):
            cfg = getattr(settings, name)
            apps[name] = {
                "url": cfg.url,
                "has_api_key": bool(cfg.api_key.get_secret_value()),
                "enabled": cfg.enabled,
                "search_interval": cfg.search_interval,
                "search_missing_count": cfg.search_missing_count,
                "search_cutoff_count": cfg.search_cutoff_count,
            }
        return templates.TemplateResponse(
            request=request,
            name="settings.html",
            context={
                "apps": apps,
                "log_level": settings.general.log_level,
            },
        )
    ```
    CRITICAL: Never pass `cfg.api_key.get_secret_value()` to the template context. Only pass `has_api_key` (boolean) to show/hide the placeholder.

    **Add POST /settings:**

    ```python
    @router.post("/settings")
    async def save_settings(request: Request):
        form = await request.form()
        current_settings = request.app.state.settings
        config_path = request.app.state.config_path
        state_path = request.app.state.state_path
        scheduler = request.app.state.scheduler
    ```

    Build new config dict from form data:
    ```python
    new_config = {
        "general": {
            "log_level": form.get("log_level", "info"),
        },
    }

    for name in ("radarr", "sonarr"):
        current_cfg = getattr(current_settings, name)
        submitted_key = form.get(f"{name}_api_key", "").strip()
        new_config[name] = {
            "url": form.get(f"{name}_url", "").strip(),
            "api_key": submitted_key if submitted_key else current_cfg.api_key.get_secret_value(),
            "enabled": form.get(f"{name}_enabled") == "on",
            "search_interval": int(form.get(f"{name}_search_interval", 30)),
            "search_missing_count": int(form.get(f"{name}_search_missing_count", 5)),
            "search_cutoff_count": int(form.get(f"{name}_search_cutoff_count", 5)),
        }
    ```

    Write TOML and reload:
    ```python
    import tomli_w
    config_path.write_text(tomli_w.dumps(new_config))

    from fetcharr.config import load_settings
    new_settings = load_settings(config_path)
    request.app.state.settings = new_settings
    ```

    Handle scheduler updates for each app:
    ```python
    for name in ("radarr", "sonarr"):
        new_cfg = getattr(new_settings, name)
        old_cfg = getattr(current_settings, name)
        job_id = f"{name}_search"
        existing_job = scheduler.get_job(job_id)

        if not new_cfg.enabled:
            # Disable: remove job and close client
            if existing_job:
                scheduler.remove_job(job_id)
            client = getattr(request.app.state, f"{name}_client", None)
            if client:
                await client.close()
                setattr(request.app.state, f"{name}_client", None)
            logger.info("{name} disabled", name=name.title())

        elif new_cfg.enabled:
            # Check if client needs recreation (URL or API key changed)
            url_changed = new_cfg.url != old_cfg.url
            key_changed = new_cfg.api_key.get_secret_value() != old_cfg.api_key.get_secret_value()

            if url_changed or key_changed or not getattr(request.app.state, f"{name}_client", None):
                # Close old client if exists
                old_client = getattr(request.app.state, f"{name}_client", None)
                if old_client:
                    await old_client.close()
                # Create new client
                ClientClass = RadarrClient if name == "radarr" else SonarrClient
                new_client = ClientClass(
                    base_url=new_cfg.url,
                    api_key=new_cfg.api_key.get_secret_value(),
                )
                setattr(request.app.state, f"{name}_client", new_client)

            if existing_job:
                # Reschedule with new interval
                scheduler.reschedule_job(
                    job_id,
                    trigger="interval",
                    minutes=new_cfg.search_interval,
                )
            else:
                # Add new job for newly-enabled app
                from fetcharr.search.scheduler import make_search_job
                job_fn = make_search_job(request.app, name, state_path)
                scheduler.add_job(
                    job_fn, "interval",
                    minutes=new_cfg.search_interval,
                    id=job_id,
                    next_run_time=datetime.now(timezone.utc),
                )
                logger.info(
                    "Enabled {name} search every {interval}m",
                    name=name.title(), interval=new_cfg.search_interval,
                )
    ```

    Add required imports at the top of routes.py:
    ```python
    from datetime import datetime, timezone
    from fastapi.responses import RedirectResponse
    from loguru import logger
    from fetcharr.clients.radarr import RadarrClient
    from fetcharr.clients.sonarr import SonarrClient
    ```

    Return PRG redirect:
    ```python
    return RedirectResponse(url="/settings", status_code=303)
    ```

    **Add POST /api/search-now/{app_name}:**

    ```python
    @router.post("/api/search-now/{app_name}", response_class=HTMLResponse)
    async def search_now(request: Request, app_name: str):
        if app_name not in ("radarr", "sonarr"):
            return HTMLResponse("Invalid app", status_code=400)

        client = getattr(request.app.state, f"{app_name}_client", None)
        if client is None:
            return HTMLResponse("App not enabled", status_code=400)

        from fetcharr.search.engine import run_radarr_cycle, run_sonarr_cycle
        from fetcharr.state import save_state

        cycle_fn = run_radarr_cycle if app_name == "radarr" else run_sonarr_cycle
        try:
            request.app.state.fetcharr_state = await cycle_fn(
                client,
                request.app.state.fetcharr_state,
                request.app.state.settings,
            )
            save_state(
                request.app.state.fetcharr_state,
                request.app.state.state_path,
            )
            logger.info("{name}: Manual search triggered", name=app_name.title())
        except Exception as exc:
            logger.error("{name}: Manual search failed -- {exc}", name=app_name.title(), exc=exc)

        # Return updated card partial
        app_data = _build_app_context(request, app_name)
        return templates.TemplateResponse(
            request=request,
            name="partials/app_card.html",
            context={"app": app_data},
        )
    ```

    **Rewrite fetcharr/templates/settings.html:**
    Extends `base.html`. Sets nav_settings active. Content structure:

    ```html
    {% extends "base.html" %}
    {% block title %}Settings - Fetcharr{% endblock %}
    {% block content %}
    <h1 class="text-2xl font-bold mb-6">Settings</h1>

    <form method="post" action="/settings" class="space-y-8">
        <!-- General section -->
        <section class="bg-fetcharr-card rounded-lg border border-fetcharr-border p-5">
            <h2 class="text-lg font-semibold mb-4">General</h2>
            <div class="grid grid-cols-1 gap-4 max-w-md">
                <div>
                    <label class="block text-sm text-fetcharr-muted mb-1">Log Level</label>
                    <select name="log_level"
                            class="w-full bg-fetcharr-bg border border-fetcharr-border rounded px-3 py-2 text-sm">
                        {% for level in ['debug', 'info', 'warning', 'error'] %}
                        <option value="{{ level }}" {% if log_level == level %}selected{% endif %}>
                            {{ level | capitalize }}
                        </option>
                        {% endfor %}
                    </select>
                </div>
            </div>
        </section>

        <!-- Per-app sections: Radarr, Sonarr -->
        {% for name, app in apps.items() %}
        <section class="bg-fetcharr-card rounded-lg border border-fetcharr-border p-5">
            <div class="flex items-center justify-between mb-4">
                <h2 class="text-lg font-semibold capitalize">{{ name }}</h2>
                <label class="flex items-center gap-2 cursor-pointer">
                    <input type="checkbox" name="{{ name }}_enabled"
                           {% if app.enabled %}checked{% endif %}
                           class="accent-fetcharr-green w-4 h-4">
                    <span class="text-sm">Enabled</span>
                </label>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                    <label class="block text-sm text-fetcharr-muted mb-1">URL</label>
                    <input type="text" name="{{ name }}_url" value="{{ app.url }}"
                           placeholder="http://{{ name }}:{% if name == 'radarr' %}7878{% else %}8989{% endif %}"
                           class="w-full bg-fetcharr-bg border border-fetcharr-border rounded px-3 py-2 text-sm">
                </div>
                <div>
                    <label class="block text-sm text-fetcharr-muted mb-1">API Key</label>
                    <input type="password" name="{{ name }}_api_key" value=""
                           placeholder="{{ '********' if app.has_api_key else 'Paste API key' }}"
                           class="w-full bg-fetcharr-bg border border-fetcharr-border rounded px-3 py-2 text-sm">
                </div>
                <div>
                    <label class="block text-sm text-fetcharr-muted mb-1">Search Interval (minutes)</label>
                    <input type="number" name="{{ name }}_search_interval" value="{{ app.search_interval }}"
                           min="1" class="w-full bg-fetcharr-bg border border-fetcharr-border rounded px-3 py-2 text-sm">
                </div>
                <div>
                    <label class="block text-sm text-fetcharr-muted mb-1">Missing Items Per Cycle</label>
                    <input type="number" name="{{ name }}_search_missing_count" value="{{ app.search_missing_count }}"
                           min="1" class="w-full bg-fetcharr-bg border border-fetcharr-border rounded px-3 py-2 text-sm">
                </div>
                <div>
                    <label class="block text-sm text-fetcharr-muted mb-1">Cutoff Items Per Cycle</label>
                    <input type="number" name="{{ name }}_search_cutoff_count" value="{{ app.search_cutoff_count }}"
                           min="1" class="w-full bg-fetcharr-bg border border-fetcharr-border rounded px-3 py-2 text-sm">
                </div>
            </div>
        </section>
        {% endfor %}

        <div class="flex justify-end">
            <button type="submit"
                    class="bg-fetcharr-green hover:bg-fetcharr-green-dark text-white font-medium px-6 py-2 rounded transition-colors">
                Save Settings
            </button>
        </div>
    </form>
    {% endblock %}
    ```

    Key points:
    - API key input is `type="password"` with `value=""` (NEVER the actual key)
    - Placeholder shows "********" if key exists, "Paste API key" if not
    - Empty submission means "keep existing key" (handled in POST route)
    - Enabled checkbox uses `name="{name}_enabled"` — unchecked checkboxes don't send form data, so `form.get("{name}_enabled") == "on"` returns False when unchecked
    - All number inputs have `min="1"` for basic browser validation

    **Update fetcharr/templates/partials/app_card.html:**
    Add a controls row at the bottom of the card (after the stats grid):
    ```html
    <!-- Controls -->
    <div class="flex items-center gap-3 mt-4 pt-3 border-t border-fetcharr-border/50">
        <button hx-post="/api/search-now/{{ app.name }}"
                hx-target="#{{ app.name }}-card"
                hx-swap="outerHTML"
                class="bg-fetcharr-green/20 text-fetcharr-green text-xs font-medium px-3 py-1.5 rounded
                       hover:bg-fetcharr-green/30 transition-colors">
            Search Now
        </button>
    </div>
    ```

    The "Search Now" button:
    - Uses `hx-post` to trigger an immediate cycle via htmx
    - `hx-target` points to the card container so the response (updated card partial) replaces the card
    - `hx-swap="outerHTML"` replaces the entire card div (including htmx polling attributes)
    - No full page reload — the card updates inline

    **Recompile Tailwind CSS:**
    ```bash
    cd /Users/julianamacbook/fetcharr
    tailwindcss -i fetcharr/static/css/input.css -o fetcharr/static/css/output.css --minify
    ```
  </action>
  <verify>
    <automated>cd /Users/julianamacbook/fetcharr && python -c "
import inspect
from fetcharr.web.routes import save_settings, search_now, settings_page

# Verify POST /settings exists and handles form data
save_src = inspect.getsource(save_settings)
assert 'tomli_w' in save_src, 'POST /settings missing TOML write'
assert 'load_settings' in save_src, 'POST /settings missing reload'
assert '303' in save_src, 'POST /settings missing PRG redirect'
assert 'reschedule_job' in save_src, 'POST /settings missing reschedule'
print('POST /settings OK')

# Verify search-now exists
search_src = inspect.getsource(search_now)
assert 'run_radarr_cycle' in search_src or 'cycle_fn' in search_src, 'search-now missing cycle call'
print('Search-now OK')

# Verify settings page never leaks API keys
settings_src = inspect.getsource(settings_page)
assert 'get_secret_value' not in settings_src or 'has_api_key' in settings_src, 'Settings page may leak API key'
print('API key masking OK')

# Check templates
from pathlib import Path
settings_html = Path('fetcharr/templates/settings.html').read_text()
assert 'type=\"password\"' in settings_html or 'password' in settings_html, 'API key field not password type'
assert '********' in settings_html, 'Missing placeholder for existing key'
assert 'method=\"post\"' in settings_html or 'method=post' in settings_html, 'Form missing POST method'
print('Settings template OK')

card_html = Path('fetcharr/templates/partials/app_card.html').read_text()
assert 'search-now' in card_html, 'Card missing Search Now button'
assert 'hx-post' in card_html, 'Card missing htmx POST'
print('App card Search Now OK')

print('ALL PASSED')
"</automated>
  </verify>
  <done>Config editor complete: GET renders masked form, POST writes TOML and hot-reloads with scheduler reschedule/toggle. Search Now button on dashboard cards triggers immediate cycles via htmx. API keys never exposed in HTML.</done>
</task>

<task type="auto">
  <name>Task 2: Web route test suite</name>
  <files>tests/test_web.py</files>
  <action>
    Create a comprehensive test suite for web routes. Uses `fastapi.testclient.TestClient` for synchronous endpoint testing.

    **Test fixture:**
    Create a `test_app` fixture that builds a minimal FastAPI app with mock state on `app.state`:
    ```python
    import pytest
    from fastapi import FastAPI
    from fastapi.testclient import TestClient
    from unittest.mock import MagicMock, AsyncMock
    from pathlib import Path
    from fetcharr.web.routes import router, STATIC_DIR

    @pytest.fixture
    def test_app(tmp_path):
        app = FastAPI()
        # Don't mount static files in tests (avoids aiofiles dependency)
        app.include_router(router)

        # Mock app.state
        app.state.fetcharr_state = {
            "radarr": {
                "missing_cursor": 3,
                "cutoff_cursor": 1,
                "last_run": "2026-01-15T10:30:00Z",
                "connected": True,
                "unreachable_since": None,
                "missing_count": 42,
                "cutoff_count": 7,
            },
            "sonarr": {
                "missing_cursor": 0,
                "cutoff_cursor": 0,
                "last_run": None,
                "connected": None,
                "unreachable_since": None,
                "missing_count": None,
                "cutoff_count": None,
            },
            "search_log": [
                {"name": "Test Movie", "timestamp": "2026-01-15T10:30:00Z", "app": "Radarr", "queue_type": "missing"},
            ],
        }

        mock_settings = MagicMock()
        mock_settings.radarr.enabled = True
        mock_settings.radarr.url = "http://radarr:7878"
        mock_settings.radarr.api_key.get_secret_value.return_value = "test-radarr-key"
        mock_settings.radarr.search_interval = 30
        mock_settings.radarr.search_missing_count = 5
        mock_settings.radarr.search_cutoff_count = 5
        mock_settings.sonarr.enabled = True
        mock_settings.sonarr.url = "http://sonarr:8989"
        mock_settings.sonarr.api_key.get_secret_value.return_value = "test-sonarr-key"
        mock_settings.sonarr.search_interval = 30
        mock_settings.sonarr.search_missing_count = 5
        mock_settings.sonarr.search_cutoff_count = 5
        mock_settings.general.log_level = "info"
        app.state.settings = mock_settings

        mock_scheduler = MagicMock()
        mock_job = MagicMock()
        mock_job.next_run_time = None  # Avoid datetime formatting
        mock_scheduler.get_job.return_value = mock_job
        app.state.scheduler = mock_scheduler

        app.state.radarr_client = MagicMock()
        app.state.sonarr_client = MagicMock()
        app.state.config_path = tmp_path / "fetcharr.toml"
        app.state.state_path = tmp_path / "state.json"

        return app

    @pytest.fixture
    def client(test_app):
        return TestClient(test_app)
    ```

    **Tests:**

    1. `test_dashboard_returns_200(client)` — GET / returns 200 and contains "Radarr" in response body
    2. `test_dashboard_shows_search_log(client)` — GET / response contains "Test Movie" from mock search_log
    3. `test_settings_page_returns_200(client)` — GET /settings returns 200
    4. `test_settings_page_does_not_leak_api_keys(client)` — GET /settings response does NOT contain "test-radarr-key" or "test-sonarr-key"
    5. `test_settings_page_shows_masked_placeholder(client)` — GET /settings response contains "********" placeholder
    6. `test_app_card_partial_returns_200(client)` — GET /partials/app-card/radarr returns 200
    7. `test_app_card_partial_has_htmx_attributes(client)` — Response contains `hx-trigger` and `every 5s`
    8. `test_search_log_partial_returns_200(client)` — GET /partials/search-log returns 200
    9. `test_save_settings_writes_toml(client, test_app, tmp_path)` — POST /settings with form data writes TOML file to config_path. Verify file exists and contains expected values. Verify redirect (303).
    10. `test_save_settings_preserves_existing_api_key(client, test_app, tmp_path)` — POST /settings with empty api_key field preserves the existing key in the written TOML
    11. `test_save_settings_replaces_api_key_when_provided(client, test_app, tmp_path)` — POST /settings with new api_key value writes the new key to TOML
    12. `test_search_now_invalid_app(client)` — POST /api/search-now/invalid returns 400

    For POST /settings tests: mock `load_settings` return value and scheduler methods. The TestClient follows redirects by default — use `allow_redirects=False` to test the 303 response, or check the final GET response.

    Each test is a standalone function (no classes). Use descriptive assertions with messages.
  </action>
  <verify>
    <automated>cd /Users/julianamacbook/fetcharr && python -m pytest tests/test_web.py -v --tb=short 2>&1 | tail -25</automated>
  </verify>
  <done>12 web route tests covering: dashboard rendering, search log display, settings form (no API key leakage, masked placeholders), config save (TOML write, key preservation, key replacement, PRG redirect), htmx attributes on partials, and search-now validation. All tests pass.</done>
</task>

</tasks>

<verification>
- `python -m pytest tests/ -v` passes (all existing + new web tests)
- GET /settings shows form fields but never actual API key values
- POST /settings writes TOML and reloads settings
- POST /api/search-now/radarr triggers a cycle
- Dashboard cards have a working "Search Now" button
- All templates reference the correct htmx POST endpoints
</verification>

<success_criteria>
- WEBU-05: User can edit all settings via web UI config editor without file editing
- WEBU-07: User can enable/disable each app via toggle without changing other config
- WEBU-08: User can trigger an immediate search cycle per app via "search now" button
- Config editor never displays API key values (SECR-01 maintained)
- POST /settings uses PRG pattern (303 redirect)
- Hot reload updates settings, reschedules jobs, and manages clients
- Search Now button triggers immediate cycle via htmx POST
- 12+ web tests pass covering all routes and security invariants
- All existing Phase 1 and Phase 2 tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-web-ui/03-03-SUMMARY.md`
</output>
