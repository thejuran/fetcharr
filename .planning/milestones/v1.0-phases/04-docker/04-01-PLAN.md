---
phase: 04-docker
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Dockerfile
  - entrypoint.sh
  - .dockerignore
  - docker-compose.yml
  - fetcharr/startup.py
autonomous: true
requirements:
  - DEPL-01

must_haves:
  truths:
    - "`docker compose up` starts Fetcharr and the web UI is reachable in a browser"
    - "Config and state files live on a named Docker volume at /config and survive container recreation"
    - "No API keys or config values are baked into the Docker image layers -- all credentials are runtime-only via the volume-mounted config file"
    - "Startup emits a clear warning (not a silent hang) if an enabled *arr URL contains localhost/127.0.0.1"
    - "Container runs as non-root user via PUID/PGID environment variables"
    - "Docker HEALTHCHECK hits the web UI endpoint and reports health status"
  artifacts:
    - path: "Dockerfile"
      provides: "Multi-stage build: pytailwindcss builder + python:3.13-slim production"
      contains: "FROM python:3.13-slim"
    - path: "entrypoint.sh"
      provides: "PUID/PGID user creation and privilege dropping via setpriv"
      contains: "setpriv --reuid"
    - path: ".dockerignore"
      provides: "Build context exclusions for .venv, .git, tests, .planning"
      contains: ".venv"
    - path: "docker-compose.yml"
      provides: "Service definition with named volume, port 8080, PUID/PGID env, unless-stopped"
      contains: "fetcharr_config:/config"
    - path: "fetcharr/startup.py"
      provides: "Localhost URL detection warning before connection validation"
      contains: "localhost"
  key_links:
    - from: "Dockerfile"
      to: "entrypoint.sh"
      via: "COPY and ENTRYPOINT directive"
      pattern: "ENTRYPOINT.*entrypoint\\.sh"
    - from: "Dockerfile"
      to: "fetcharr/static/css/output.css"
      via: "COPY --from=builder compiled CSS into production stage"
      pattern: "COPY --from=builder"
    - from: "docker-compose.yml"
      to: "Dockerfile"
      via: "build context reference or image name"
      pattern: "ghcr\\.io/thejuran/fetcharr"
    - from: "entrypoint.sh"
      to: "fetcharr/__main__.py"
      via: "exec setpriv ... python -m fetcharr"
      pattern: "python -m fetcharr"
    - from: "fetcharr/startup.py"
      to: "fetcharr/models/config.py"
      via: "Reads settings.radarr.url and settings.sonarr.url for localhost check"
      pattern: "urlparse.*\\.url"
---

<objective>
Create Docker packaging for Fetcharr: multi-stage Dockerfile with pytailwindcss builder stage and slim production image, docker-compose.yml with named volume, PUID/PGID entrypoint, HEALTHCHECK, and localhost URL detection at startup.

Purpose: Enable self-hosters to run Fetcharr as a Docker container with `docker compose up`, following *arr ecosystem conventions (/config volume, PUID/PGID, LinuxServer.io patterns).

Output: Dockerfile, entrypoint.sh, .dockerignore, docker-compose.yml, and updated startup.py with localhost detection.
</objective>

<execution_context>
@/Users/julianamacbook/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julianamacbook/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-docker/04-RESEARCH.md
@fetcharr/startup.py
@fetcharr/config.py
@fetcharr/__main__.py
@fetcharr/models/config.py
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Docker artifacts (Dockerfile, entrypoint, compose, dockerignore)</name>
  <files>
    Dockerfile
    entrypoint.sh
    .dockerignore
    docker-compose.yml
  </files>
  <action>
Create four files at the project root:

**Dockerfile** — Two-stage multi-stage build:

Stage 1 (`builder`): Based on `python:3.13-slim`. Set `ENV TAILWINDCSS_VERSION=v4.2.1`. Copy `pyproject.toml` and `fetcharr/` directory. Run `pip install --no-cache-dir pytailwindcss`, then `tailwindcss_install`, then `tailwindcss -i fetcharr/static/css/input.css -o fetcharr/static/css/output.css --minify`. This stage only produces the compiled CSS artifact.

Stage 2 (production): Based on `python:3.13-slim`. Set `ENV PYTHONUNBUFFERED=1 PYTHONDONTWRITEBYTECODE=1`. WORKDIR `/app`. Copy `pyproject.toml` and `fetcharr/` then `pip install --no-cache-dir .` (runtime deps only, no dev extras). Copy compiled `output.css` from builder via `COPY --from=builder /build/fetcharr/static/css/output.css fetcharr/static/css/output.css`. Copy `entrypoint.sh` to `/entrypoint.sh` and `chmod +x`. EXPOSE 8080. VOLUME /config. Add HEALTHCHECK: `--interval=30s --timeout=5s --start-period=10s --retries=3 CMD python3 -c "import urllib.request; urllib.request.urlopen('http://localhost:8080/')" || exit 1`. Set `ENTRYPOINT ["/entrypoint.sh"]`. Do NOT use CMD — the entrypoint exec's python directly. Add a comment near TAILWINDCSS_VERSION explaining the pin.

**entrypoint.sh** — Bash script (LF line endings, `#!/bin/bash`, `set -e`):
1. Read `PUID` and `PGID` env vars with defaults of 1000
2. Validate both are numeric; if not, warn and reset to 1000
3. Create group with `groupadd -g "$PGID" fetcharr` if GID doesn't exist (`getent group "$PGID"`)
4. Create user with `useradd -u "$PUID" -g "$PGID" -d /config -s /sbin/nologin fetcharr` if UID doesn't exist
5. `chown -R "$PUID:$PGID" /config`
6. `exec setpriv --reuid="$PUID" --regid="$PGID" --init-groups python -m fetcharr`

The `exec` is critical — it replaces the shell process so Python becomes PID 1 and receives SIGTERM from `docker stop`.

**.dockerignore** — Exclude: `.venv/`, `venv/`, `.git/`, `.gitignore`, `__pycache__/`, `*.py[cod]`, `*.egg-info/`, `dist/`, `build/`, `.pytest_cache/`, `tests/`, `.planning/`, `.idea/`, `.vscode/`, `.DS_Store`, `*.swp`

**docker-compose.yml** — Modern format (no `version:` field):
- Service `fetcharr` with `image: ghcr.io/thejuran/fetcharr:latest`, `container_name: fetcharr`
- Environment: `PUID=1000`, `PGID=1000`
- Volumes: `fetcharr_config:/config`
- Ports: `"8080:8080"`
- Restart: `unless-stopped`
- Top-level `volumes:` declaring `fetcharr_config:`
- Add a comment explaining users can replace `image:` with `build: .` for local builds
  </action>
  <verify>
    <automated>test -f Dockerfile && test -f entrypoint.sh && test -f .dockerignore && test -f docker-compose.yml && grep -q "FROM python:3.13-slim" Dockerfile && grep -q "setpriv" entrypoint.sh && grep -q "fetcharr_config:/config" docker-compose.yml && grep -q ".venv" .dockerignore && echo "PASS" || echo "FAIL"</automated>
    <manual>Review Dockerfile stages, entrypoint logic, compose volume mapping</manual>
  </verify>
  <done>
    - Dockerfile has two stages: builder (pytailwindcss + CSS compilation) and production (python:3.13-slim, runtime deps, compiled CSS, HEALTHCHECK, VOLUME /config, ENTRYPOINT)
    - entrypoint.sh creates PUID/PGID user, chowns /config, exec's setpriv to drop privileges
    - docker-compose.yml has named volume, port 8080, PUID/PGID env, unless-stopped restart
    - .dockerignore excludes .venv, .git, tests, .planning, __pycache__
  </done>
</task>

<task type="auto">
  <name>Task 2: Add localhost URL detection to startup</name>
  <files>
    fetcharr/startup.py
    tests/test_startup.py
  </files>
  <action>
Add a `check_localhost_urls` function to `fetcharr/startup.py` that warns if any enabled app's URL points to localhost (a common Docker networking mistake).

**Implementation:**
1. Import `urlparse` from `urllib.parse` at the top of startup.py
2. Define `LOCALHOST_PATTERNS = {"localhost", "127.0.0.1", "::1"}` as a module-level constant
3. Create `check_localhost_urls(settings: Settings) -> None`:
   - For each app name ("radarr", "sonarr"), get the config via `getattr(settings, name)`
   - Skip if not enabled
   - Parse `cfg.url` with `urlparse`, extract `.hostname`
   - If hostname is in `LOCALHOST_PATTERNS`, log a warning using loguru:
     `"{app} URL ({url}) uses localhost, which inside Docker refers to the container itself, not your host machine. Use 'host.docker.internal' (Docker Desktop) or the container/service name (e.g. 'http://radarr:7878') instead."`
   - Format with `app=name.title(), url=cfg.url`
4. Call `check_localhost_urls(settings)` in the `startup()` function AFTER logging setup (step 3) and banner (step 4) but BEFORE connection validation (step 5). Add it as step 4.5 with a comment: `# 4.5 Warn about localhost URLs (common Docker networking mistake)`. This placement ensures the warning is visible in logs before the inevitable connection failure.

**Test:**
Add a test to `tests/test_startup.py` (or create it if it doesn't exist) that verifies:
- `check_localhost_urls` logs a warning when an enabled app has `localhost` in its URL
- `check_localhost_urls` does NOT log a warning for non-localhost URLs
- `check_localhost_urls` skips disabled apps even if they have localhost URLs

Use loguru's `capfd` or a sink capture pattern. If existing test patterns use a different approach, follow those. The test should construct a Settings object with the necessary fields (use the same pattern as existing tests — check tests/ for examples).
  </action>
  <verify>
    <automated>cd /Users/julianamacbook/fetcharr && python -m pytest tests/ -x -q 2>&1 | tail -5</automated>
    <manual>Verify warning message mentions host.docker.internal and container service name</manual>
  </verify>
  <done>
    - `check_localhost_urls` function exists in startup.py and is called during startup sequence
    - Warning logged for enabled apps with localhost/127.0.0.1/::1 URLs
    - Warning suggests host.docker.internal and container service name as alternatives
    - Disabled apps with localhost URLs produce no warning
    - All existing tests still pass
  </done>
</task>

</tasks>

<verification>
1. All four Docker files exist at project root: Dockerfile, entrypoint.sh, .dockerignore, docker-compose.yml
2. Dockerfile has multi-stage build with pytailwindcss builder and python:3.13-slim production
3. Dockerfile HEALTHCHECK uses python3 urllib.request (no curl)
4. entrypoint.sh uses setpriv for non-root execution with PUID/PGID
5. docker-compose.yml uses named volume `fetcharr_config` mapped to `/config`
6. No API keys or config values appear anywhere in Docker files
7. startup.py warns about localhost URLs before connection validation
8. All tests pass (existing + new localhost detection tests)
</verification>

<success_criteria>
- `docker compose config` validates the compose file without errors
- `grep -r "api_key\|API_KEY" Dockerfile docker-compose.yml entrypoint.sh` returns nothing (no baked credentials)
- `python -m pytest tests/ -x` passes all tests including new localhost detection tests
- Dockerfile contains HEALTHCHECK, VOLUME /config, EXPOSE 8080, ENTRYPOINT
- entrypoint.sh contains setpriv, PUID, PGID, chown, exec
</success_criteria>

<output>
After completion, create `.planning/phases/04-docker/04-01-SUMMARY.md`
</output>
