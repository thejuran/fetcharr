---
phase: 06-bug-fixes-and-resilience
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - fetcharr/state.py
  - tests/test_state.py
autonomous: true
requirements:
  - QUAL-03
  - QUAL-04

must_haves:
  truths:
    - "Corrupt or truncated state.json recovers to default state instead of crashing"
    - "Temp files from failed os.replace calls are cleaned up, not left as orphans"
    - "An old state file missing new keys (e.g. missing_count) loads successfully with defaults filled in"
    - "A valid state file still loads correctly with all values preserved"
  artifacts:
    - path: "fetcharr/state.py"
      provides: "_merge_defaults helper, corrupt-state recovery, temp-file cleanup"
      contains: "_merge_defaults"
    - path: "tests/test_state.py"
      provides: "Tests for corrupt recovery, schema migration, temp cleanup"
      contains: "test_state_corrupt_recovers"
  key_links:
    - from: "fetcharr/state.py"
      to: "json.JSONDecodeError"
      via: "try/except in load_state"
      pattern: "except.*JSONDecodeError"
    - from: "fetcharr/state.py"
      to: "os.unlink"
      via: "cleanup in save_state except block"
      pattern: "os\\.unlink"
---

<objective>
Harden state file read/write: corrupt state recovery, schema migration, and temp file cleanup.

Purpose: Prevent crashes from corrupt or schema-drifted state files, and eliminate temp file leaks on write failures. These are the QUAL-03 (atomic write cleanup + corrupt recovery) and QUAL-04 (missing key migration) fixes.

Output: Updated `fetcharr/state.py` with defensive read/write, plus tests proving recovery and migration work.
</objective>

<execution_context>
@/Users/julianamacbook/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julianamacbook/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-bug-fixes-and-resilience/06-RESEARCH.md
@fetcharr/state.py
@tests/test_state.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Harden state.py with corrupt recovery, schema migration, and temp cleanup</name>
  <files>fetcharr/state.py</files>
  <action>
Three targeted changes to `fetcharr/state.py`:

**1. Add `_merge_defaults` helper (QUAL-04):**
Add a new function `_merge_defaults(loaded: dict) -> FetcharrState` between `_default_state` and `load_state`. It merges loaded state over a fresh default so any missing keys get default values. Use shallow merge per app key: `{**defaults["radarr"], **loaded["radarr"]}`. Replace `search_log` wholesale (it's a list, not a dict). Only merge if the loaded value is the correct type (dict for apps, list for search_log).

**2. Harden `load_state` (QUAL-03 read side + QUAL-04):**
Wrap `json.load(f)` in try/except catching both `json.JSONDecodeError` and `OSError`. On exception, log a warning via loguru: `"Corrupt state file at {path} -- resetting to defaults"` and return `_default_state()`. On successful parse, return `_merge_defaults(data)` instead of returning `data` directly. Add `from loguru import logger` import at the top.

**3. Harden `save_state` (QUAL-03 write side):**
Wrap the `os.replace(tmp.name, state_path)` call in try/except `OSError`. In the except block, attempt `os.unlink(tmp.name)` wrapped in its own try/except `OSError` (swallow the unlink failure), then re-raise the original `OSError`. This ensures temp files don't leak even if `os.replace` fails.

Do NOT change function signatures or the `FetcharrState`/`AppState` type definitions. The `save_state` fix wraps the existing `os.replace` line. The `load_state` fix replaces the existing `with open(state_path) as f: return json.load(f)` block.
  </action>
  <verify>
    <automated>cd /Users/julianamacbook/fetcharr && python -m pytest tests/test_state.py -x -q</automated>
    <manual>Verify existing state round-trip tests still pass (no regression)</manual>
  </verify>
  <done>state.py has _merge_defaults, corrupt recovery in load_state, and temp cleanup in save_state. All existing tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Add tests for corrupt state recovery, schema migration, and temp cleanup</name>
  <files>tests/test_state.py</files>
  <action>
Add four new test functions to `tests/test_state.py`:

**1. `test_state_corrupt_recovers_to_defaults`:**
Write garbage text ("not valid json") to a state file path in `tmp_path`. Call `load_state(state_file)`. Assert it returns a valid default state (both apps at cursor 0, empty search_log). Verifies QUAL-03 read-side recovery.

**2. `test_state_schema_migration_fills_missing_keys`:**
Write a minimal JSON file with only `{"radarr": {"missing_cursor": 42}, "sonarr": {}}` (no `cutoff_cursor`, no `last_run`, no `search_log`). Call `load_state(state_file)`. Assert: `radarr.missing_cursor == 42` (preserved), `radarr.cutoff_cursor == 0` (filled from default), `radarr.last_run is None` (filled from default), `sonarr.missing_cursor == 0` (filled from default), `search_log == []` (filled from default). Verifies QUAL-04.

**3. `test_state_schema_migration_preserves_all_existing`:**
Write a complete valid state JSON to a file. Call `load_state`. Assert all values are preserved exactly (not overwritten by defaults). Verifies QUAL-04 doesn't break existing valid files.

**4. `test_save_state_cleans_temp_on_replace_failure`:**
Use `unittest.mock.patch("fetcharr.state.os.replace", side_effect=OSError("mock failure"))`. Call `save_state(state, state_file)` wrapped in `pytest.raises(OSError)`. After the failure, assert no `.tmp` files remain in the `tmp_path` directory. Verifies QUAL-03 write-side cleanup.

Follow existing test patterns: use `tmp_path` fixture, import from `fetcharr.state`.
  </action>
  <verify>
    <automated>cd /Users/julianamacbook/fetcharr && python -m pytest tests/test_state.py -x -q</automated>
    <manual>All 8 state tests pass (4 existing + 4 new)</manual>
  </verify>
  <done>Four new tests cover corrupt recovery, schema migration (fill + preserve), and temp file cleanup on write failure. All 8 tests pass.</done>
</task>

</tasks>

<verification>
```bash
cd /Users/julianamacbook/fetcharr && python -m pytest tests/test_state.py -x -v
```
All state tests pass including the four new ones. No regression in existing behavior.
</verification>

<success_criteria>
- `load_state` returns defaults for corrupt/truncated JSON (no crash)
- `load_state` fills missing keys from defaults for old state files
- `load_state` preserves all existing values for complete state files
- `save_state` cleans up temp files when `os.replace` fails
- All 8 state tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-bug-fixes-and-resilience/06-01-SUMMARY.md`
</output>
