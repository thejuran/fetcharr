---
phase: 14-dashboard-observability
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - fetcharr/log_buffer.py
  - fetcharr/logging.py
  - fetcharr/templates/partials/log_viewer.html
  - fetcharr/templates/dashboard.html
  - fetcharr/web/routes.py
  - tests/test_log_buffer.py
autonomous: true
requirements: [WEBU-10]

must_haves:
  truths:
    - "Dashboard has a dedicated section showing recent application log messages"
    - "Log messages update via htmx polling without page refresh"
    - "Log viewer shows timestamp, level, and message for each entry"
    - "Log buffer is bounded and does not grow unbounded in memory"
  artifacts:
    - path: "fetcharr/log_buffer.py"
      provides: "In-memory ring buffer loguru sink for capturing recent log messages"
      min_lines: 30
    - path: "fetcharr/templates/partials/log_viewer.html"
      provides: "htmx-polled log viewer partial template"
      contains: "hx-get"
    - path: "fetcharr/web/routes.py"
      provides: "Log viewer partial endpoint"
      contains: "partials/log-viewer"
  key_links:
    - from: "fetcharr/logging.py"
      to: "fetcharr/log_buffer.py"
      via: "setup_logging adds log_buffer sink"
      pattern: "log_buffer"
    - from: "fetcharr/web/routes.py"
      to: "fetcharr/log_buffer.py"
      via: "route reads from log buffer"
      pattern: "get_recent_logs"
    - from: "fetcharr/templates/dashboard.html"
      to: "fetcharr/templates/partials/log_viewer.html"
      via: "Jinja2 include"
      pattern: "include.*log_viewer"
---

<objective>
Add a dedicated application log viewer section to the dashboard that displays recent loguru messages.

Purpose: Users currently have no visibility into application logs from the web UI -- they must check container stdout/stderr. A live-updating log viewer section on the dashboard lets users see what Fetcharr is doing (search cycles, errors, connection issues) without leaving the browser.

Output: An in-memory ring buffer module that captures loguru messages, a log viewer partial template with htmx polling, a new partial endpoint, and integration into the dashboard page.
</objective>

<execution_context>
@/Users/julianamacbook/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julianamacbook/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@fetcharr/logging.py
@fetcharr/templates/dashboard.html
@fetcharr/templates/base.html
@fetcharr/web/routes.py
@fetcharr/static/css/input.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create log buffer module and wire into loguru</name>
  <files>
    fetcharr/log_buffer.py
    fetcharr/logging.py
  </files>
  <action>
**Create `fetcharr/log_buffer.py`:**

Implement a thread-safe in-memory ring buffer for capturing loguru messages:

```python
"""In-memory ring buffer for capturing recent loguru messages for the web UI.

Uses collections.deque with maxlen for automatic bounded storage.
Thread-safe via deque's atomic append operations.
"""

from __future__ import annotations

import threading
from collections import deque
from dataclasses import dataclass
from datetime import UTC, datetime


@dataclass(frozen=True, slots=True)
class LogEntry:
    """A single captured log message."""
    timestamp: str  # ISO format string
    level: str      # e.g. "INFO", "WARNING", "ERROR"
    message: str    # The log message text (already formatted, no timestamp/level prefix)


class LogBuffer:
    """Bounded ring buffer that stores recent log entries for UI display.

    Uses a deque with maxlen for automatic eviction of oldest entries.
    """

    def __init__(self, maxlen: int = 100) -> None:
        self._entries: deque[LogEntry] = deque(maxlen=maxlen)
        self._lock = threading.Lock()

    def sink(self, message) -> None:
        """Loguru-compatible sink that captures formatted messages.

        Extract level and clean message from the loguru record,
        then append to the buffer. The `message` parameter is a
        loguru Message object with a `record` attribute.
        """
        record = message.record
        entry = LogEntry(
            timestamp=record["time"].strftime("%Y-%m-%d %H:%M:%S"),
            level=record["level"].name,
            message=record["message"],
        )
        with self._lock:
            self._entries.append(entry)

    def get_recent(self, limit: int = 50) -> list[LogEntry]:
        """Return the most recent log entries, newest first."""
        with self._lock:
            entries = list(self._entries)
        # Reverse to get newest first
        entries.reverse()
        return entries[:limit]

    def clear(self) -> None:
        """Clear all entries from the buffer."""
        with self._lock:
            self._entries.clear()


# Module-level singleton, created once at import time
log_buffer = LogBuffer(maxlen=200)
```

**Update `fetcharr/logging.py`:**

In `setup_logging`, after adding the redacting sink, also add the log_buffer sink. Import `log_buffer` from `fetcharr.log_buffer`. Add the buffer sink at the SAME level as the redacting sink but with NO format string (the buffer stores raw record data, not formatted text):

After the existing `logger.add(create_redacting_sink(...), ...)` line, add:

```python
from fetcharr.log_buffer import log_buffer

logger.add(
    log_buffer.sink,
    level=level.upper(),
    format="{message}",  # Buffer only needs the message text
)
```

Important: Place the import at the top of the file (not inside the function). The `log_buffer.sink` is the method on the singleton -- loguru will call it for each log message at or above the configured level.

Note: The buffer sink does NOT need the redacting sink wrapper because it captures `record["message"]` which is the template-substituted message, not the formatted output. However, we should still redact secrets in the buffer. To handle this, wrap the buffer sink: create a function `_make_redacting_buffer_sink(secrets, buffer)` that creates a sink which redacts secrets from `record["message"]` before passing to `buffer.sink`. Use this instead of `log_buffer.sink` directly.

Actually, simpler approach: In LogBuffer.sink, the `record["message"]` is the already-template-substituted message. Secrets could appear here (e.g., if a log message accidentally includes a secret). Since setup_logging already has the secrets list, create the buffer sink as a closure in setup_logging:

```python
def buffer_sink(message):
    text = message.record["message"]
    for secret in secrets:
        if secret:
            text = text.replace(secret, "[REDACTED]")
    # Create entry with redacted message
    from fetcharr.log_buffer import LogEntry, log_buffer
    entry = LogEntry(
        timestamp=message.record["time"].strftime("%Y-%m-%d %H:%M:%S"),
        level=message.record["level"].name,
        message=text,
    )
    with log_buffer._lock:
        log_buffer._entries.append(entry)

logger.add(buffer_sink, level=level.upper(), format="{message}")
```

Wait, that's cleaner but accesses private attributes. Better approach: Add a `add_entry(entry)` method to LogBuffer, or just have the buffer store the entry directly. Let's keep it simple:

1. In `LogBuffer`, add method `add(self, entry: LogEntry)` that appends with lock.
2. In `logging.py`, the `setup_logging` function creates a closure that redacts and calls `log_buffer.add(...)`.
3. Remove the `sink` method from LogBuffer (the closure in logging.py handles the loguru interface).

Final design:
- `LogBuffer` has `add(entry)` and `get_recent(limit)` and `clear()`.
- `logging.py` creates a closure sink that redacts secrets and calls `log_buffer.add(LogEntry(...))`.
- This keeps secret handling in logging.py where the secrets list lives.
  </action>
  <verify>
    <automated>cd /Users/julianamacbook/fetcharr && uv run python -c "from fetcharr.log_buffer import LogBuffer, LogEntry; b = LogBuffer(5); b.add(LogEntry('ts', 'INFO', 'test')); assert len(b.get_recent()) == 1; print('OK')"</automated>
    <manual>Verify log_buffer.py exists and logging.py imports it</manual>
  </verify>
  <done>
    - LogBuffer class exists with add(), get_recent(), clear() methods
    - LogEntry dataclass captures timestamp, level, message
    - Module-level log_buffer singleton with 200 entry capacity
    - setup_logging adds a redacting buffer sink alongside the stderr sink
    - Secrets are redacted in buffer entries just like in stderr output
  </done>
</task>

<task type="auto">
  <name>Task 2: Add log viewer template, partial endpoint, and tests</name>
  <files>
    fetcharr/templates/partials/log_viewer.html
    fetcharr/templates/dashboard.html
    fetcharr/web/routes.py
    tests/test_log_buffer.py
    tests/test_web.py
  </files>
  <action>
**Create `fetcharr/templates/partials/log_viewer.html`:**

A self-contained htmx-polled partial that displays recent log messages in a scrollable container:

```html
<div id="log-viewer"
     hx-get="/partials/log-viewer"
     hx-trigger="every 5s"
     hx-swap="outerHTML"
     class="bg-fetcharr-card rounded-lg border border-fetcharr-border p-5">
  <h2 class="text-lg font-semibold mb-4">Application Log</h2>
  {% if not log_entries %}
  <p class="text-fetcharr-muted text-sm">No log messages yet.</p>
  {% else %}
  <div class="space-y-0 max-h-64 overflow-y-auto font-mono text-xs">
    {% for entry in log_entries[:30] %}
    <div class="flex items-start gap-2 py-1 {% if not loop.last %}border-b border-fetcharr-border/30{% endif %}">
        <span class="text-fetcharr-muted whitespace-nowrap">{{ entry.timestamp }}</span>
        <span class="font-medium whitespace-nowrap
               {% if entry.level == 'ERROR' %}text-red-400
               {% elif entry.level == 'WARNING' %}text-yellow-400
               {% elif entry.level == 'DEBUG' %}text-fetcharr-muted
               {% else %}text-fetcharr-green{% endif %}">
            {{ entry.level }}
        </span>
        <span class="text-fetcharr-text break-all">{{ entry.message }}</span>
    </div>
    {% endfor %}
  </div>
  {% endif %}
</div>
```

Key design choices:
- `max-h-64 overflow-y-auto` makes the log scrollable without taking over the page
- `font-mono text-xs` for log-appropriate monospace display
- Color-coded levels: green=INFO, yellow=WARNING, red=ERROR, muted=DEBUG
- 30 entries displayed (newest first from get_recent)
- htmx polls every 5s, matching the existing polling pattern

**Update `fetcharr/templates/dashboard.html`:**

Add the log viewer include AFTER the search log include. Inside the `{% if apps %}` block, after `{% include "partials/search_log.html" %}`, add:

```html
<div class="mt-4">
  {% include "partials/log_viewer.html" %}
</div>
```

**Update `fetcharr/web/routes.py`:**

1. Add import at top: `from fetcharr.log_buffer import log_buffer`

2. Update the `dashboard` function to pass `log_entries` to the template context:
   ```python
   log_entries = log_buffer.get_recent(30)
   ```
   Add `"log_entries": log_entries` to the context dict. Also need to convert LogEntry dataclass instances to dicts for Jinja2 template access. Either:
   - Use `[{"timestamp": e.timestamp, "level": e.level, "message": e.message} for e in log_entries]`
   - Or access attributes directly in Jinja2 (Jinja2 supports attribute access on dataclasses)

   Jinja2 supports attribute access on Python objects, so passing LogEntry instances directly works. Use `entry.timestamp`, `entry.level`, `entry.message` in the template (already done above).

3. Add new partial endpoint:
   ```python
   @router.get("/partials/log-viewer", response_class=HTMLResponse)
   async def partial_log_viewer(request: Request) -> HTMLResponse:
       """Return an HTML fragment for the application log viewer (htmx partial)."""
       log_entries = log_buffer.get_recent(30)
       return templates.TemplateResponse(
           request=request,
           name="partials/log_viewer.html",
           context={"log_entries": log_entries},
       )
   ```

**Create `tests/test_log_buffer.py`:**

Test the LogBuffer class:

1. `test_log_buffer_add_and_get`: Create a LogBuffer(maxlen=5), add 3 entries, verify get_recent returns 3 entries in newest-first order.

2. `test_log_buffer_maxlen_evicts_oldest`: Create a LogBuffer(maxlen=3), add 5 entries, verify only the 3 newest remain.

3. `test_log_buffer_clear`: Add entries, call clear(), verify get_recent returns empty list.

4. `test_log_buffer_get_recent_limit`: Add 10 entries, call get_recent(limit=3), verify only 3 returned.

5. `test_log_buffer_thread_safe`: Add entries from multiple threads, verify no exceptions and entry count is correct.

**Update `tests/test_web.py`:**

1. `test_dashboard_shows_log_viewer_section`: GET `/` and assert the response contains "Application Log" (the log viewer heading). Need to ensure log_buffer is importable; since the dashboard route now imports from log_buffer, this should work. If needed, add a few entries to log_buffer before the request and assert they appear.

2. `test_log_viewer_partial_returns_200`: GET `/partials/log-viewer` returns 200.

Note: The test_app fixture does NOT need modification for log_buffer since it's a module-level singleton. However, clear it in fixture setup to avoid test pollution: add `log_buffer.clear()` at the start of the test_app fixture, and import log_buffer.
  </action>
  <verify>
    <automated>cd /Users/julianamacbook/fetcharr && uv run pytest tests/test_log_buffer.py tests/test_web.py -x -q</automated>
  </verify>
  <done>
    - Log viewer partial template exists with htmx polling
    - Dashboard includes the log viewer section below the search log
    - New /partials/log-viewer endpoint returns 200 with log entries
    - LogBuffer has at least 5 tests covering add, eviction, clear, limit, threading
    - Log viewer shows color-coded levels (INFO=green, WARNING=yellow, ERROR=red)
    - Log entries display timestamp, level, and message
    - All existing tests continue to pass
  </done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/ -x -q` -- All tests pass (existing + new)
2. `uv run ruff check fetcharr/ tests/` -- No lint violations
3. Dashboard page (GET /) contains "Application Log" section
4. `/partials/log-viewer` endpoint returns 200 with correct htmx attributes
5. LogBuffer singleton captures messages when setup_logging is called
</verification>

<success_criteria>
- Dashboard has a dedicated "Application Log" section showing recent loguru messages
- Log messages are color-coded by level (INFO/WARNING/ERROR/DEBUG)
- Log viewer polls every 5s via htmx for live updates
- Buffer is bounded at 200 entries (no memory leak)
- Secrets are redacted in buffer entries
- At least 5 new tests for LogBuffer, at least 2 new tests for web integration
</success_criteria>

<output>
After completion, create `.planning/phases/14-dashboard-observability/14-02-SUMMARY.md`
</output>
