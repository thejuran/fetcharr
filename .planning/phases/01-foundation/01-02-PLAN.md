---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - fetcharr/models/arr.py
  - fetcharr/clients/base.py
  - fetcharr/clients/radarr.py
  - fetcharr/clients/sonarr.py
autonomous: true
requirements:
  - CONN-01
  - CONN-02

must_haves:
  truths:
    - "Base ArrClient wraps httpx.AsyncClient with base_url and X-Api-Key header"
    - "RadarrClient can fetch all pages of wanted/missing and wanted/cutoff from Radarr"
    - "SonarrClient can fetch all pages of wanted/missing and wanted/cutoff from Sonarr with includeSeries=true"
    - "Pagination terminates correctly for zero-record responses"
    - "API call failures retry once with 2-second delay, then raise"
    - "HTTP timeout is 30 seconds for all requests"
  artifacts:
    - path: "fetcharr/clients/base.py"
      provides: "ArrClient base class with get_paginated and connection validation"
      contains: "httpx.AsyncClient"
    - path: "fetcharr/clients/radarr.py"
      provides: "RadarrClient with wanted/missing and wanted/cutoff methods"
      contains: "class RadarrClient"
    - path: "fetcharr/clients/sonarr.py"
      provides: "SonarrClient with wanted/missing and wanted/cutoff methods"
      contains: "class SonarrClient"
    - path: "fetcharr/models/arr.py"
      provides: "Response models for *arr API data"
      contains: "class PaginatedResponse"
  key_links:
    - from: "fetcharr/clients/base.py"
      to: "httpx.AsyncClient"
      via: "wraps with base_url and X-Api-Key header"
      pattern: "httpx\\.AsyncClient"
    - from: "fetcharr/clients/radarr.py"
      to: "fetcharr/clients/base.py"
      via: "extends ArrClient"
      pattern: "class RadarrClient\\(ArrClient\\)"
    - from: "fetcharr/clients/sonarr.py"
      to: "fetcharr/clients/base.py"
      via: "extends ArrClient"
      pattern: "class SonarrClient\\(ArrClient\\)"
---

<objective>
Build httpx-based async API clients for Radarr and Sonarr with paginated list fetching, retry logic, and connection validation.

Purpose: Provide the HTTP communication layer that connects Fetcharr to *arr applications. These clients are used by the startup validation flow (Plan 03) and by the search engine (Phase 2).
Output: Working ArrClient base class with RadarrClient and SonarrClient subclasses capable of fetching paginated wanted/cutoff lists.
</objective>

<execution_context>
@/Users/julianamacbook/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julianamacbook/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create response models and ArrClient base class with pagination and retry</name>
  <files>
    fetcharr/models/arr.py
    fetcharr/clients/base.py
  </files>
  <action>
    1. Create `fetcharr/models/arr.py` with response models:
       - `PaginatedResponse(BaseModel)`: `page: int`, `pageSize: int`, `sortKey: str`, `totalRecords: int`, `records: list[dict[str, Any]]`
         - This is the shared pagination envelope for all *arr API list endpoints
       - `SystemStatus(BaseModel)`: `version: str` plus `model_config = ConfigDict(extra="ignore")` to ignore extra fields from the API response -- we only need the version string for startup logging

    2. Create `fetcharr/clients/base.py` with `ArrClient` base class:
       - `__init__(self, base_url: str, api_key: str, timeout: float = 30.0)`:
         - Create `httpx.AsyncClient` with:
           - `base_url=base_url`
           - `headers={"X-Api-Key": api_key, "Content-Type": "application/json"}` (Content-Type for Sonarr v4 compatibility per research pitfall #3)
           - `timeout=httpx.Timeout(timeout)`
         - Store `_app_name` as empty string (overridden by subclasses)

       - `async def get(self, path: str, params: dict | None = None) -> httpx.Response`:
         - Simple wrapper around `self._client.get()` for direct API calls

       - `async def post(self, path: str, json_data: dict) -> httpx.Response`:
         - Simple wrapper around `self._client.post(json=json_data)` for command calls (used in Phase 2)

       - `async def get_paginated(self, path: str, page_size: int = 50, extra_params: dict | None = None) -> list[dict]`:
         - Fetch all pages from a paginated *arr endpoint
         - Start at page 1 (1-indexed, per research)
         - Each request: `params={"page": page, "pageSize": page_size, "sortKey": "id", **extra_params}`
         - Parse response into `PaginatedResponse` model
         - Terminate when: `len(records) == 0` OR `page * page_size >= totalRecords`
         - Handle `totalRecords: 0` as immediate return of empty list
         - Log total items fetched: `logger.debug(f"Fetched {len(all_records)} items from {path} ({total_records} total)")`
         - Log total item count per STATE.md concern about diagnosing unexpected truncation

       - `async def _request_with_retry(self, method: str, path: str, **kwargs) -> httpx.Response`:
         - Execute request, on failure (httpx.HTTPStatusError, httpx.ConnectError, httpx.TimeoutException) wait 2 seconds and retry once
         - If retry also fails, log warning and re-raise the exception
         - Use this method internally for all get/post calls
         - The 2-second delay before retry is per research recommendation (Claude's discretion item)

       - `async def validate_connection(self) -> bool`:
         - GET `/api/v3/system/status`
         - On success: parse `SystemStatus`, log `Connected to {app_name} v{version}`, return True
         - On 401: log error `{app_name}: API key is invalid (401 Unauthorized)`, return False
         - On ConnectError: log warning `{app_name}: Connection refused at configured URL`, return False
         - On TimeoutException: log warning `{app_name}: Connection timed out (30s)`, return False

       - `async def close(self)`: Call `self._client.aclose()`
       - `async def __aenter__` / `async def __aexit__`: Context manager support

    Import loguru's `logger` for all logging. NEVER use `traceback.print_exc()` -- always use `logger.exception()` or `logger.warning()` which go through the redaction filter pipeline (per research pitfall #1).
  </action>
  <verify>
    <automated>cd /Users/julianamacbook/fetcharr && python -c "
from fetcharr.clients.base import ArrClient
from fetcharr.models.arr import PaginatedResponse, SystemStatus
import inspect

# Verify class structure
assert hasattr(ArrClient, 'get_paginated'), 'Missing get_paginated'
assert hasattr(ArrClient, 'validate_connection'), 'Missing validate_connection'
assert hasattr(ArrClient, 'close'), 'Missing close'
assert inspect.iscoroutinefunction(ArrClient.get_paginated), 'get_paginated must be async'
assert inspect.iscoroutinefunction(ArrClient.validate_connection), 'validate_connection must be async'

# Verify models
pr = PaginatedResponse(page=1, pageSize=50, sortKey='id', totalRecords=0, records=[])
assert pr.totalRecords == 0
ss = SystemStatus(version='4.5.2')
assert ss.version == '4.5.2'
print('Base client and models OK')
"</automated>
  </verify>
  <done>
    - ArrClient wraps httpx.AsyncClient with base_url, X-Api-Key header, 30s timeout
    - get_paginated exhausts all pages, handles zero-record edge case, logs item counts
    - _request_with_retry retries once with 2-second delay on failure
    - validate_connection calls /api/v3/system/status with specific error handling for 401, connection refused, timeout
    - All logging goes through loguru (never traceback.print_exc)
    - PaginatedResponse and SystemStatus models parse *arr API responses
  </done>
</task>

<task type="auto">
  <name>Task 2: Create RadarrClient and SonarrClient subclasses with wanted/cutoff methods</name>
  <files>
    fetcharr/clients/radarr.py
    fetcharr/clients/sonarr.py
  </files>
  <action>
    1. Create `fetcharr/clients/radarr.py` with `RadarrClient(ArrClient)`:
       - `__init__`: Call super().__init__, set `self._app_name = "Radarr"`
       - `async def get_wanted_missing(self) -> list[dict]`:
         - Call `self.get_paginated("/api/v3/wanted/missing")`
         - Return the list of movie records
       - `async def get_wanted_cutoff(self) -> list[dict]`:
         - Call `self.get_paginated("/api/v3/wanted/cutoff")`
         - Return the list of movie records

    2. Create `fetcharr/clients/sonarr.py` with `SonarrClient(ArrClient)`:
       - `__init__`: Call super().__init__, set `self._app_name = "Sonarr"`
       - `async def get_wanted_missing(self) -> list[dict]`:
         - Call `self.get_paginated("/api/v3/wanted/missing", extra_params={"includeSeries": "true"})`
         - `includeSeries=true` is needed for human-readable log messages and season-level deduplication in Phase 2
         - Return the list of episode records
       - `async def get_wanted_cutoff(self) -> list[dict]`:
         - Call `self.get_paginated("/api/v3/wanted/cutoff", extra_params={"includeSeries": "true"})`
         - Return the list of episode records

    The subclasses are thin wrappers -- all HTTP logic, pagination, retry, and error handling lives in the base class. The subclasses only define app-specific endpoint paths and parameters.

    Export both clients from `fetcharr/clients/__init__.py`:
    ```python
    from fetcharr.clients.radarr import RadarrClient
    from fetcharr.clients.sonarr import SonarrClient
    ```
  </action>
  <verify>
    <automated>cd /Users/julianamacbook/fetcharr && python -c "
from fetcharr.clients import RadarrClient, SonarrClient
import inspect

# Verify RadarrClient
assert issubclass(RadarrClient, (object,)), 'RadarrClient must be a class'
assert hasattr(RadarrClient, 'get_wanted_missing')
assert hasattr(RadarrClient, 'get_wanted_cutoff')
assert inspect.iscoroutinefunction(RadarrClient.get_wanted_missing)

# Verify SonarrClient
assert issubclass(SonarrClient, (object,)), 'SonarrClient must be a class'
assert hasattr(SonarrClient, 'get_wanted_missing')
assert hasattr(SonarrClient, 'get_wanted_cutoff')
assert inspect.iscoroutinefunction(SonarrClient.get_wanted_missing)

print('Radarr and Sonarr clients OK')
"</automated>
  </verify>
  <done>
    - RadarrClient fetches wanted/missing and wanted/cutoff movie lists via paginated endpoints
    - SonarrClient fetches wanted/missing and wanted/cutoff episode lists with includeSeries=true
    - Both subclasses inherit retry, pagination, validation, and error handling from ArrClient
    - Both clients exported from fetcharr.clients package
  </done>
</task>

</tasks>

<verification>
1. `python -c "from fetcharr.clients import RadarrClient, SonarrClient; print('Clients importable')"` -- both clients importable
2. `python -c "from fetcharr.models.arr import PaginatedResponse, SystemStatus; print('Models OK')"` -- response models work
3. ArrClient.validate_connection handles 401, ConnectError, TimeoutException with specific log messages
4. Pagination handles zero records without infinite loop
5. All requests include X-Api-Key header and Content-Type: application/json
</verification>

<success_criteria>
- RadarrClient and SonarrClient are importable and have correct async method signatures
- Base ArrClient uses httpx.AsyncClient with X-Api-Key header auth (never URL params)
- Pagination logic terminates correctly for empty and multi-page results
- Retry logic retries once with 2-second delay
- Connection validation provides specific error messages per failure type
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
