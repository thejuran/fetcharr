---
phase: 01-foundation
plan: 03
type: execute
wave: 3
depends_on:
  - 01-01
  - 01-02
files_modified:
  - fetcharr/__main__.py
  - fetcharr/startup.py
  - tests/test_config.py
  - tests/test_state.py
  - tests/test_clients.py
  - tests/__init__.py
autonomous: true
requirements:
  - CONN-01
  - CONN-02
  - SECR-01

must_haves:
  truths:
    - "Fetcharr starts up, loads config, sets up logging with redaction, validates connections, and prints startup banner"
    - "Missing config file generates a default template and exits with helpful message"
    - "Unreachable Radarr or Sonarr logs a warning and keeps running"
    - "At least one app must be configured -- exits with error if both missing"
    - "Startup banner shows app name, version, connected apps, and log level"
    - "Tests verify config loading, state persistence, client structure, and API key redaction"
  artifacts:
    - path: "fetcharr/__main__.py"
      provides: "Entry point for python -m fetcharr"
      contains: "async def main"
    - path: "fetcharr/startup.py"
      provides: "Startup orchestration: config loading, logging setup, validation, banner"
      contains: "async def startup"
    - path: "tests/test_config.py"
      provides: "Tests for config loading, default generation, validation"
      contains: "def test_"
    - path: "tests/test_state.py"
      provides: "Tests for state load/save with atomic write"
      contains: "def test_"
    - path: "tests/test_clients.py"
      provides: "Tests for client structure, pagination, retry"
      contains: "def test_"
  key_links:
    - from: "fetcharr/__main__.py"
      to: "fetcharr/startup.py"
      via: "calls startup() to initialize app"
      pattern: "from fetcharr\\.startup import"
    - from: "fetcharr/startup.py"
      to: "fetcharr/config.py"
      via: "calls ensure_config() for config loading"
      pattern: "ensure_config"
    - from: "fetcharr/startup.py"
      to: "fetcharr/logging.py"
      via: "calls setup_logging() with secrets list"
      pattern: "setup_logging"
    - from: "fetcharr/startup.py"
      to: "fetcharr/clients/base.py"
      via: "calls validate_connection() on each enabled client"
      pattern: "validate_connection"
---

<objective>
Wire together the startup flow (config loading, logging setup, connection validation, startup banner) and create the test suite covering config, state, and client modules.

Purpose: Make Fetcharr runnable as `python -m fetcharr` with full startup orchestration. Prove all Phase 1 requirements work with automated tests.
Output: Working entry point, startup orchestration module, and test suite.
</objective>

<execution_context>
@/Users/julianamacbook/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julianamacbook/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create startup orchestration and entry point</name>
  <files>
    fetcharr/startup.py
    fetcharr/__main__.py
  </files>
  <action>
    1. Create `fetcharr/startup.py` with startup orchestration:

       - `def collect_secrets(settings: Settings) -> list[str]`:
         - Extract API key values from all configured apps using `.get_secret_value()`
         - Return list of non-empty secret strings for the redaction filter
         - This is the ONLY place where get_secret_value() is called for logging purposes

       - `def print_banner(settings: Settings) -> None`:
         - Log startup banner using loguru:
           ```
           ==================================================
           Fetcharr v{version}
           Log level: {settings.general.log_level}
           Radarr: {settings.radarr.url} (or "disabled")
           Sonarr: {settings.sonarr.url} (or "disabled")
           ==================================================
           ```
         - Show URL for enabled apps, "disabled" for disabled apps

       - `async def validate_connections(settings: Settings) -> dict[str, bool]`:
         - For each enabled app (radarr, sonarr):
           - Create the appropriate client (RadarrClient or SonarrClient)
           - Call `client.validate_connection()`
           - Close client after validation (clients will be recreated by the search engine in Phase 2)
           - Collect results: `{"radarr": True/False, "sonarr": True/False}`
         - If an app is disabled, skip it (don't include in results)
         - Per locked decision: if unreachable, log warning and keep running -- do NOT exit

       - `async def startup(config_path: Path | None = None) -> Settings`:
         - Call `ensure_config(config_path or CONFIG_PATH)` -- exits if missing
         - Call `collect_secrets(settings)` to get API key values
         - Call `setup_logging(settings.general.log_level, secrets)`
         - Call `print_banner(settings)`
         - Call `validate_connections(settings)`
         - Log summary: which apps connected, which failed
         - Return settings for use by the rest of the app

    2. Create `fetcharr/__main__.py`:
       - `def main()`:
         - Import and call `asyncio.run(startup())`
         - For Phase 1, after startup just log "Fetcharr started. Search engine not yet implemented." and keep running (the search loop comes in Phase 2)
         - Wrap in try/except for KeyboardInterrupt to exit cleanly
       - `if __name__ == "__main__": main()`

    Important: The startup function accepts an optional config_path parameter for testability. Production uses the default `/config/fetcharr.toml`; tests can pass a temp directory path.
  </action>
  <verify>
    <automated>cd /Users/julianamacbook/fetcharr && python -c "
from fetcharr.startup import collect_secrets, print_banner, validate_connections, startup
from fetcharr.__main__ import main
import inspect

assert inspect.iscoroutinefunction(validate_connections)
assert inspect.iscoroutinefunction(startup)
assert callable(main)
print('Startup and entry point OK')
"</automated>
  </verify>
  <done>
    - startup() orchestrates: config load -> logging setup (with redaction) -> banner -> validation
    - Missing config generates default template and exits with helpful message
    - Unreachable *arr apps log warnings but don't crash the process
    - Entry point works via `python -m fetcharr`
    - Config path is parameterizable for testing
  </done>
</task>

<task type="auto">
  <name>Task 2: Create test suite for config, state, clients, and security invariants</name>
  <files>
    tests/__init__.py
    tests/test_config.py
    tests/test_state.py
    tests/test_clients.py
  </files>
  <action>
    Add `pytest` and `pytest-asyncio` to dev dependencies in pyproject.toml (under `[project.optional-dependencies]` dev group or `[tool.pytest.ini_options]`). Add `[tool.pytest.ini_options]` with `asyncio_mode = "auto"`.

    1. Create `tests/__init__.py` (empty)

    2. Create `tests/test_config.py`:
       - `test_settings_loads_from_toml()`: Write a valid TOML config to a temp file, load Settings pointing at it, verify radarr.url, radarr.api_key (as SecretStr), sonarr sections parse correctly.
       - `test_settings_rejects_no_enabled_apps()`: Write TOML with both apps disabled/empty, assert ValidationError is raised with clear message.
       - `test_settings_allows_single_app()`: Write TOML with only radarr configured and enabled, verify it loads successfully (sonarr section omitted).
       - `test_default_config_generation()`: Call generate_default_config to a temp path, verify file exists and contains `[radarr]` and `[sonarr]` sections.
       - `test_api_key_never_in_str()`: Create ArrConfig with api_key, assert the key value does NOT appear in `str()`, `repr()`, or `.model_dump_json()`.
       - `test_ensure_config_exits_on_missing()`: Call ensure_config with nonexistent path, verify SystemExit is raised and default config was generated.

    3. Create `tests/test_state.py`:
       - `test_state_round_trip()`: Save state with cursor values, load it back, verify values match.
       - `test_state_default_on_missing_file()`: Load from nonexistent path, verify default state returned (cursors at 0).
       - `test_state_atomic_write()`: Save state, verify the file exists (not a .tmp file). Verify no .tmp files remain in the directory after save.
       - `test_state_creates_parent_dirs()`: Save to a path where parent directory doesn't exist, verify it creates it.

    4. Create `tests/test_clients.py`:
       - `test_arr_client_sets_api_key_header()`: Create ArrClient, inspect `self._client.headers` to confirm X-Api-Key is set.
       - `test_arr_client_sets_timeout()`: Create ArrClient with timeout=30, verify `self._client.timeout` reflects it.
       - `test_arr_client_sets_content_type()`: Verify Content-Type: application/json is in default headers.
       - `test_radarr_client_is_arr_client_subclass()`: Verify `issubclass(RadarrClient, ArrClient)`.
       - `test_sonarr_client_is_arr_client_subclass()`: Verify `issubclass(SonarrClient, ArrClient)`.
       - `test_radarr_client_app_name()`: Create RadarrClient, verify `_app_name == "Radarr"`.
       - `test_sonarr_client_app_name()`: Create SonarrClient, verify `_app_name == "Sonarr"`.
       - `test_api_key_not_in_url()`: Create ArrClient, verify the API key is in headers only and not part of base_url.

    5. Create `tests/test_logging.py` (add to files):
       - `test_redaction_filter_removes_secret()`: Set up loguru with redaction filter, log a message containing the secret, verify secret is replaced with [REDACTED] in output.
       - `test_redaction_filter_ignores_empty_secrets()`: Verify empty strings in secrets list don't cause issues.
       - `test_log_format_matches_spec()`: Set up logging, verify output matches `YYYY-MM-DD HH:MM:SS LEVEL    Message` format.

    All tests must use `tmp_path` fixture or `tempfile.TemporaryDirectory` for file operations -- never write to production paths.
  </action>
  <verify>
    <automated>cd /Users/julianamacbook/fetcharr && pip install -e ".[dev]" 2>/dev/null; pip install pytest pytest-asyncio 2>/dev/null; python -m pytest tests/ -v --tb=short 2>&1 | tail -30</automated>
  </verify>
  <done>
    - All tests pass with `pytest tests/ -v`
    - Config tests verify TOML loading, validation, default generation, and SecretStr security
    - State tests verify atomic write, round-trip persistence, default values
    - Client tests verify header auth, timeout, subclass structure
    - Logging tests verify redaction filter strips secrets from output
    - No test writes to production paths -- all use temp directories
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/ -v` -- all tests pass
2. `python -c "from fetcharr.startup import startup; print('Startup OK')"` -- startup module importable
3. `python -m fetcharr --help` or `python -m fetcharr` shows entry point works (will exit on missing config in production path)
4. Security invariant: no test output contains any API key value
5. All Phase 1 requirements covered: CONN-01 (Radarr config+validation), CONN-02 (Sonarr config+validation), SECR-01 (key redaction+SecretStr)
</verification>

<success_criteria>
- `python -m pytest tests/ -v` passes all tests with zero failures
- Startup flow: config load -> redacted logging -> banner -> connection validation
- Missing config generates default and exits with helpful message
- Unreachable *arr apps warn but don't crash
- API keys never appear in test output, log messages, or string representations
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
