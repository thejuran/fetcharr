---
phase: 02-search-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - fetcharr/models/config.py
  - fetcharr/config.py
  - fetcharr/clients/radarr.py
  - fetcharr/clients/sonarr.py
  - fetcharr/search/__init__.py
  - fetcharr/search/engine.py
autonomous: true
requirements: [CONF-01, CONF-02, SRCH-09, SRCH-11]

must_haves:
  truths:
    - "ArrConfig accepts search_interval, search_missing_count, search_cutoff_count with sensible defaults (30, 5, 5)"
    - "Existing config files without new fields still load without error (backward compatible)"
    - "Default config template includes commented-out search tuning fields for both apps"
    - "RadarrClient.search_movies() posts MoviesSearch command with movieIds array"
    - "SonarrClient.search_season() posts SeasonSearch command with seriesId and seasonNumber"
    - "Unmonitored items are filtered out before batch slicing"
    - "Search log entries contain item name, timestamp, app name, and queue type"
    - "Search log is bounded at 50 entries with oldest-first eviction"
  artifacts:
    - path: "fetcharr/models/config.py"
      provides: "ArrConfig with search_interval, search_missing_count, search_cutoff_count fields"
      contains: "search_interval"
    - path: "fetcharr/clients/radarr.py"
      provides: "search_movies method for MoviesSearch command"
      contains: "MoviesSearch"
    - path: "fetcharr/clients/sonarr.py"
      provides: "search_season method for SeasonSearch command"
      contains: "SeasonSearch"
    - path: "fetcharr/search/engine.py"
      provides: "Core search engine utility functions"
      contains: "filter_monitored"
    - path: "fetcharr/search/__init__.py"
      provides: "Search subpackage marker"
  key_links:
    - from: "fetcharr/search/engine.py"
      to: "fetcharr/state.py"
      via: "append_search_log modifies state dict"
      pattern: "search_log"
    - from: "fetcharr/clients/radarr.py"
      to: "ArrClient.post"
      via: "search_movies calls self.post with MoviesSearch payload"
      pattern: "MoviesSearch"
    - from: "fetcharr/clients/sonarr.py"
      to: "ArrClient.post"
      via: "search_season calls self.post with SeasonSearch payload"
      pattern: "SeasonSearch"
---

<objective>
Extend config models with search tuning fields, add search command methods to API clients, and create the search engine module with core utility functions (filtering, batch slicing, search logging).

Purpose: Establish the foundation for search cycles -- config drives batch sizes and intervals, client methods trigger actual searches, and utility functions handle the common patterns shared by both Radarr and Sonarr cycles.

Output: Extended config models, client search methods, and `fetcharr/search/engine.py` with filter_monitored, slice_batch, and append_search_log functions.
</objective>

<execution_context>
@/Users/julianamacbook/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julianamacbook/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-search-engine/02-CONTEXT.md
@.planning/phases/02-search-engine/02-RESEARCH.md
@fetcharr/models/config.py
@fetcharr/config.py
@fetcharr/clients/base.py
@fetcharr/clients/radarr.py
@fetcharr/clients/sonarr.py
@fetcharr/state.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend config models with search tuning fields and add client search methods</name>
  <files>
    fetcharr/models/config.py
    fetcharr/config.py
    fetcharr/clients/radarr.py
    fetcharr/clients/sonarr.py
  </files>
  <action>
    **Config model extension (fetcharr/models/config.py):**
    Add three new fields to ArrConfig with defaults so existing configs remain backward-compatible:
    - `search_interval: int = 30` (minutes between search cycles)
    - `search_missing_count: int = 5` (missing items to search per cycle)
    - `search_cutoff_count: int = 5` (cutoff items to search per cycle)
    All fields use `Field(default=...)` with Pydantic. These defaults match the user's locked decisions.

    **Default config template (fetcharr/config.py):**
    Add commented-out search fields to both [radarr] and [sonarr] sections in DEFAULT_CONFIG:
    ```
    # search_interval = 30       # Minutes between search cycles
    # search_missing_count = 5   # Missing items to search per cycle
    # search_cutoff_count = 5    # Cutoff items to search per cycle
    ```
    Commented out because defaults are sensible -- users only uncomment to override.

    **RadarrClient.search_movies (fetcharr/clients/radarr.py):**
    Add method:
    ```python
    async def search_movies(self, movie_ids: list[int]) -> httpx.Response:
        """Trigger a MoviesSearch command for the given movie IDs."""
        return await self.post(
            "/api/v3/command",
            json_data={"name": "MoviesSearch", "movieIds": movie_ids},
        )
    ```
    Note: movieIds MUST be an array (not a single int) per Radarr API spec.

    **SonarrClient.search_season (fetcharr/clients/sonarr.py):**
    Add method:
    ```python
    async def search_season(self, series_id: int, season_number: int) -> httpx.Response:
        """Trigger a SeasonSearch command for a specific season."""
        return await self.post(
            "/api/v3/command",
            json_data={
                "name": "SeasonSearch",
                "seriesId": series_id,
                "seasonNumber": season_number,
            },
        )
    ```
  </action>
  <verify>
    <automated>cd /Users/julianamacbook/fetcharr && python -c "
from fetcharr.models.config import ArrConfig
a = ArrConfig()
assert a.search_interval == 30
assert a.search_missing_count == 5
assert a.search_cutoff_count == 5
a2 = ArrConfig(url='http://test:7878', api_key='key', enabled=True)
assert a2.search_interval == 30
print('Config fields OK')
from fetcharr.clients.radarr import RadarrClient
from fetcharr.clients.sonarr import SonarrClient
assert hasattr(RadarrClient, 'search_movies')
assert hasattr(SonarrClient, 'search_season')
print('Client methods OK')
from fetcharr.config import DEFAULT_CONFIG
assert 'search_interval' in DEFAULT_CONFIG
print('Default config OK')
print('ALL PASSED')
"</automated>
  </verify>
  <done>ArrConfig has three new fields with backward-compatible defaults, both clients have search command methods, and the default config template includes commented search fields.</done>
</task>

<task type="auto">
  <name>Task 2: Create search engine module with core utility functions</name>
  <files>
    fetcharr/search/__init__.py
    fetcharr/search/engine.py
  </files>
  <action>
    **Create fetcharr/search/__init__.py:**
    Empty package marker file (same pattern as clients/__init__.py).

    **Create fetcharr/search/engine.py with these functions:**

    1. `filter_monitored(items: list[dict]) -> list[dict]` — Filter out items where `monitored` is not True. Used for both Radarr movies and Sonarr episodes. Simple list comprehension: `[item for item in items if item.get("monitored", False)]`.

    2. `slice_batch(items: list, cursor: int, batch_size: int) -> tuple[list, int]` — Slice a batch starting at cursor position. If cursor >= len(items), wrap to 0 silently (per user decision: no log entry for wrap events). Returns (batch, new_cursor). If items is empty, returns ([], 0). New cursor wraps to 0 if it reaches end of list. Use the exact algorithm from the research:
       ```python
       if not items:
           return [], 0
       if cursor >= len(items):
           cursor = 0
       batch = items[cursor:cursor + batch_size]
       new_cursor = cursor + len(batch)
       if new_cursor >= len(items):
           new_cursor = 0
       return batch, new_cursor
       ```

    3. `append_search_log(state: FetcharrState, app: str, queue_type: str, item_name: str) -> None` — Append a search log entry to state["search_log"]. Entry format: `{"name": item_name, "timestamp": ISO-8601 UTC string with Z suffix, "app": app, "queue_type": queue_type}`. Cap at 50 entries (SEARCH_LOG_MAX = 50), evicting oldest when exceeded: `state["search_log"] = state["search_log"][-SEARCH_LOG_MAX:]`. Use `datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")` for timestamp.

    4. `deduplicate_to_seasons(episodes: list[dict]) -> list[dict]` — Deduplicate Sonarr episode records to unique (seriesId, seasonNumber) pairs. Returns list of dicts with keys: `seriesId`, `seasonNumber`, `display_name` (format: "Show Title - Season N"). Order preserved (first occurrence wins). Use a set of (seriesId, seasonNumber) tuples to track seen pairs. Get series title from `ep.get("series", {}).get("title", f"Series {ep['seriesId']}")`.

    5. `filter_sonarr_episodes(episodes: list[dict]) -> list[dict]` — Combines monitored filtering AND future/TBA air date filtering for Sonarr. Skip if `monitored` is not True. Skip if `airDateUtc` is None (TBA = treat as future per user decision). Skip if parsed airDateUtc is in the future. Parse dates with `datetime.fromisoformat(air_date_str.replace("Z", "+00:00"))`. On parse error, skip the episode. This function replaces filter_monitored for Sonarr queues because Sonarr needs the additional air date check.

    All functions are pure (no side effects except append_search_log which mutates the state dict in place). Import FetcharrState from fetcharr.state. Import datetime, timezone from datetime stdlib.
  </action>
  <verify>
    <automated>cd /Users/julianamacbook/fetcharr && python -c "
from fetcharr.search.engine import filter_monitored, slice_batch, append_search_log, deduplicate_to_seasons, filter_sonarr_episodes
from fetcharr.state import _default_state

# filter_monitored
items = [{'id': 1, 'monitored': True}, {'id': 2, 'monitored': False}, {'id': 3}]
assert len(filter_monitored(items)) == 1
assert filter_monitored(items)[0]['id'] == 1

# slice_batch
batch, cur = slice_batch([1,2,3,4,5], 0, 3)
assert batch == [1,2,3] and cur == 3
batch, cur = slice_batch([1,2,3,4,5], 3, 3)
assert batch == [4,5] and cur == 0  # wrapped
batch, cur = slice_batch([], 0, 5)
assert batch == [] and cur == 0
batch, cur = slice_batch([1,2], 10, 5)
assert batch == [1,2] and cur == 0  # cursor past end, wrapped

# append_search_log
state = _default_state()
append_search_log(state, 'Radarr', 'missing', 'Test Movie')
assert len(state['search_log']) == 1
assert state['search_log'][0]['name'] == 'Test Movie'
assert state['search_log'][0]['app'] == 'Radarr'
for i in range(55):
    append_search_log(state, 'Radarr', 'missing', f'Movie {i}')
assert len(state['search_log']) == 50  # bounded

# deduplicate_to_seasons
eps = [
    {'seriesId': 1, 'seasonNumber': 1, 'series': {'title': 'Show A'}},
    {'seriesId': 1, 'seasonNumber': 1, 'series': {'title': 'Show A'}},
    {'seriesId': 1, 'seasonNumber': 2, 'series': {'title': 'Show A'}},
    {'seriesId': 2, 'seasonNumber': 1, 'series': {'title': 'Show B'}},
]
seasons = deduplicate_to_seasons(eps)
assert len(seasons) == 3
assert seasons[0]['display_name'] == 'Show A - Season 1'

# filter_sonarr_episodes
from datetime import datetime, timezone, timedelta
past = (datetime.now(timezone.utc) - timedelta(days=1)).isoformat().replace('+00:00', 'Z')
future = (datetime.now(timezone.utc) + timedelta(days=1)).isoformat().replace('+00:00', 'Z')
eps = [
    {'monitored': True, 'airDateUtc': past},
    {'monitored': True, 'airDateUtc': future},
    {'monitored': True, 'airDateUtc': None},
    {'monitored': False, 'airDateUtc': past},
]
filtered = filter_sonarr_episodes(eps)
assert len(filtered) == 1  # only past+monitored

print('ALL PASSED')
"</automated>
  </verify>
  <done>Search engine module exists with five pure utility functions: filter_monitored, slice_batch, append_search_log, deduplicate_to_seasons, and filter_sonarr_episodes. All handle edge cases (empty lists, cursor wrapping, null dates, log eviction).</done>
</task>

</tasks>

<verification>
- `python -c "from fetcharr.models.config import ArrConfig; a=ArrConfig(); assert a.search_interval==30"` passes
- `python -c "from fetcharr.search.engine import slice_batch; assert slice_batch([1,2,3], 0, 2) == ([1,2], 2)"` passes
- Existing test suite still passes: `pytest tests/ -x`
</verification>

<success_criteria>
- ArrConfig model has search_interval, search_missing_count, search_cutoff_count with defaults
- Config files without new fields load without error (backward compatible)
- RadarrClient has search_movies method, SonarrClient has search_season method
- fetcharr/search/engine.py has filter_monitored, slice_batch, append_search_log, deduplicate_to_seasons, filter_sonarr_episodes
- All utility functions handle edge cases (empty input, cursor wrap, log eviction, null dates)
</success_criteria>

<output>
After completion, create `.planning/phases/02-search-engine/02-01-SUMMARY.md`
</output>
