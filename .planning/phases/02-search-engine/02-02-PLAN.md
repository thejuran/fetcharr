---
phase: 02-search-engine
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - fetcharr/search/engine.py
autonomous: true
requirements: [SRCH-01, SRCH-02, SRCH-03, SRCH-04, SRCH-05, SRCH-06, SRCH-07, SRCH-10]

must_haves:
  truths:
    - "run_radarr_cycle fetches missing and cutoff lists, filters, slices batches, triggers MoviesSearch, logs each item, and returns updated state"
    - "run_sonarr_cycle fetches missing and cutoff lists, filters (monitored + future air date), deduplicates to seasons, slices batches, triggers SeasonSearch, logs each item, and returns updated state"
    - "Missing and cutoff queues have independent cursors -- advancing one does not affect the other"
    - "Each app cycle updates last_run timestamp in state after completing"
    - "Individual item search failure logs a warning and continues to next item in batch (skip-and-continue)"
    - "If the *arr app is unreachable during fetch, the entire cycle aborts and cursor stays in place"
    - "Radarr search log entries show movie title"
    - "Sonarr search log entries show 'Show Title - Season N' format"
  artifacts:
    - path: "fetcharr/search/engine.py"
      provides: "run_radarr_cycle and run_sonarr_cycle async functions"
      exports: ["run_radarr_cycle", "run_sonarr_cycle"]
  key_links:
    - from: "fetcharr/search/engine.py"
      to: "fetcharr/clients/radarr.py"
      via: "run_radarr_cycle calls client.get_wanted_missing, client.get_wanted_cutoff, client.search_movies"
      pattern: "search_movies"
    - from: "fetcharr/search/engine.py"
      to: "fetcharr/clients/sonarr.py"
      via: "run_sonarr_cycle calls client.get_wanted_missing, client.get_wanted_cutoff, client.search_season"
      pattern: "search_season"
    - from: "fetcharr/search/engine.py"
      to: "fetcharr/state.py"
      via: "Both cycles read/write cursor positions and search_log in state dict"
      pattern: "missing_cursor|cutoff_cursor"
---

<objective>
Implement the Radarr and Sonarr search cycle functions that orchestrate the full fetch-filter-slice-search-log pipeline for each app.

Purpose: These are the core product functions -- they drive the automated search behavior that is the entire reason Fetcharr exists. Each cycle function composes the utility functions from Plan 01 with client calls to produce a complete search cycle.

Output: `run_radarr_cycle` and `run_sonarr_cycle` async functions in `fetcharr/search/engine.py`.
</objective>

<execution_context>
@/Users/julianamacbook/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julianamacbook/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-search-engine/02-CONTEXT.md
@.planning/phases/02-search-engine/02-RESEARCH.md
@.planning/phases/02-search-engine/02-01-SUMMARY.md
@fetcharr/search/engine.py
@fetcharr/clients/radarr.py
@fetcharr/clients/sonarr.py
@fetcharr/state.py
@fetcharr/models/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement run_radarr_cycle function</name>
  <files>fetcharr/search/engine.py</files>
  <action>
    Add `run_radarr_cycle` async function to fetcharr/search/engine.py. This function runs one complete Radarr search cycle: missing batch then cutoff batch.

    **Signature:**
    ```python
    async def run_radarr_cycle(
        client: RadarrClient,
        state: FetcharrState,
        settings: Settings,
    ) -> FetcharrState:
    ```

    **Algorithm:**
    1. Fetch current wanted lists:
       - `missing = await client.get_wanted_missing()`
       - `cutoff = await client.get_wanted_cutoff()`
    2. Filter: `missing = filter_monitored(missing)`, `cutoff = filter_monitored(cutoff)`
    3. Process missing queue:
       - Read cursor: `cursor = state["radarr"]["missing_cursor"]`
       - Slice batch: `batch, new_cursor = slice_batch(missing, cursor, settings.radarr.search_missing_count)`
       - For each movie in batch:
         - Try: `await client.search_movies([movie["id"]])`
         - Try: `append_search_log(state, "Radarr", "missing", movie["title"])`
         - Try: `logger.info("Radarr: Searched {title} (missing)", title=movie["title"])`
         - Except: `logger.warning("Radarr: Failed to search {title}: {exc}", title=movie.get("title", "unknown"), exc=exc)` -- continue to next item (skip-and-continue per user decision)
       - Update cursor: `state["radarr"]["missing_cursor"] = new_cursor`
    4. Repeat for cutoff queue:
       - Read cursor: `cursor = state["radarr"]["cutoff_cursor"]`
       - Slice batch using `settings.radarr.search_cutoff_count`
       - Same search/log/error pattern
       - Update cursor: `state["radarr"]["cutoff_cursor"] = new_cursor`
    5. Update last_run: `state["radarr"]["last_run"] = datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")`
    6. Return state

    **Error handling at top level:** Wrap the entire function body in try/except. If the fetch calls fail (client.get_wanted_missing or get_wanted_cutoff raise), catch the exception, log `"Radarr: Cycle aborted -- {exc}"`, and return state WITHOUT modifying any cursors (per user decision: on abort, cursor stays in place). Only httpx exceptions (HTTPStatusError, ConnectError, TimeoutException) and httpx.HTTPError should be caught at this level.

    Import RadarrClient from fetcharr.clients.radarr, Settings from fetcharr.models.config, and logger from loguru.
  </action>
  <verify>
    <automated>cd /Users/julianamacbook/fetcharr && python -c "
import inspect
from fetcharr.search.engine import run_radarr_cycle
sig = inspect.signature(run_radarr_cycle)
params = list(sig.parameters.keys())
assert 'client' in params
assert 'state' in params
assert 'settings' in params
assert inspect.iscoroutinefunction(run_radarr_cycle)
print('run_radarr_cycle signature OK')
print('PASSED')
"</automated>
  </verify>
  <done>run_radarr_cycle exists as an async function that takes (client, state, settings), processes missing then cutoff batches with skip-on-failure error handling, and returns updated state with new cursors and last_run timestamp. Top-level abort returns state unchanged on fetch failure.</done>
</task>

<task type="auto">
  <name>Task 2: Implement run_sonarr_cycle function</name>
  <files>fetcharr/search/engine.py</files>
  <action>
    Add `run_sonarr_cycle` async function to fetcharr/search/engine.py. This function runs one complete Sonarr search cycle with episode-to-season deduplication.

    **Signature:**
    ```python
    async def run_sonarr_cycle(
        client: SonarrClient,
        state: FetcharrState,
        settings: Settings,
    ) -> FetcharrState:
    ```

    **Algorithm:**
    1. Fetch current wanted lists:
       - `missing_episodes = await client.get_wanted_missing()`
       - `cutoff_episodes = await client.get_wanted_cutoff()`
    2. Filter Sonarr-specific (monitored + future air date):
       - `missing_episodes = filter_sonarr_episodes(missing_episodes)`
       - `cutoff_episodes = filter_sonarr_episodes(cutoff_episodes)`
    3. Deduplicate to seasons:
       - `missing_seasons = deduplicate_to_seasons(missing_episodes)`
       - `cutoff_seasons = deduplicate_to_seasons(cutoff_episodes)`
    4. Process missing queue:
       - Read cursor: `cursor = state["sonarr"]["missing_cursor"]`
       - Slice batch: `batch, new_cursor = slice_batch(missing_seasons, cursor, settings.sonarr.search_missing_count)`
       - For each season in batch:
         - Try: `await client.search_season(season["seriesId"], season["seasonNumber"])`
         - Try: `append_search_log(state, "Sonarr", "missing", season["display_name"])`
         - Try: `logger.info("Sonarr: Searched {name} (missing)", name=season["display_name"])`
         - Except: `logger.warning("Sonarr: Failed to search {name}: {exc}", name=season.get("display_name", "unknown"), exc=exc)` -- continue (skip-and-continue)
       - Update cursor: `state["sonarr"]["missing_cursor"] = new_cursor`
    5. Repeat for cutoff queue:
       - Read cursor: `cursor = state["sonarr"]["cutoff_cursor"]`
       - Slice batch using `settings.sonarr.search_cutoff_count`
       - Same search/log/error pattern
       - Update cursor: `state["sonarr"]["cutoff_cursor"] = new_cursor`
    6. Update last_run: `state["sonarr"]["last_run"] = datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")`
    7. Return state

    **Error handling at top level:** Same pattern as Radarr -- wrap fetch calls in try/except, catch httpx exceptions, log abort, return state unchanged.

    **Key difference from Radarr:** Sonarr uses `filter_sonarr_episodes` (not `filter_monitored`) because it needs air date filtering. Sonarr uses `deduplicate_to_seasons` to collapse episodes into season-level search units. Sonarr calls `client.search_season(seriesId, seasonNumber)` instead of `client.search_movies([id])`. Log entries use `season["display_name"]` which produces "Show Title - Season N" format.

    Import SonarrClient from fetcharr.clients.sonarr.
  </action>
  <verify>
    <automated>cd /Users/julianamacbook/fetcharr && python -c "
import inspect
from fetcharr.search.engine import run_sonarr_cycle
sig = inspect.signature(run_sonarr_cycle)
params = list(sig.parameters.keys())
assert 'client' in params
assert 'state' in params
assert 'settings' in params
assert inspect.iscoroutinefunction(run_sonarr_cycle)
print('run_sonarr_cycle signature OK')

# Verify both cycle functions exist alongside utilities
from fetcharr.search.engine import (
    filter_monitored, slice_batch, append_search_log,
    deduplicate_to_seasons, filter_sonarr_episodes,
    run_radarr_cycle, run_sonarr_cycle,
)
print('All engine exports OK')
print('PASSED')
"</automated>
  </verify>
  <done>run_sonarr_cycle exists as an async function that fetches episodes, filters (monitored + air date), deduplicates to seasons, slices batches, triggers SeasonSearch per season, logs with "Show Title - Season N" format, and returns updated state. Missing and cutoff queues have independent cursors. Top-level abort returns state unchanged on fetch failure.</done>
</task>

</tasks>

<verification>
- `python -c "from fetcharr.search.engine import run_radarr_cycle, run_sonarr_cycle"` imports without error
- Both functions are async coroutines accepting (client, state, settings)
- Source code contains `search_movies` call in run_radarr_cycle and `search_season` call in run_sonarr_cycle
- Source code contains `filter_sonarr_episodes` and `deduplicate_to_seasons` calls in run_sonarr_cycle
- Source code shows independent cursor reads for missing_cursor and cutoff_cursor per queue
- Existing tests pass: `pytest tests/ -x`
</verification>

<success_criteria>
- run_radarr_cycle processes missing then cutoff batches with independent cursors
- run_sonarr_cycle deduplicates episodes to seasons before batch slicing
- Both cycles use skip-and-continue on individual item failures
- Both cycles abort cleanly on fetch failure, leaving cursors unchanged
- Both cycles update last_run timestamp after completion
- Search log entries use correct format (movie title for Radarr, "Show - Season N" for Sonarr)
</success_criteria>

<output>
After completion, create `.planning/phases/02-search-engine/02-02-SUMMARY.md`
</output>
