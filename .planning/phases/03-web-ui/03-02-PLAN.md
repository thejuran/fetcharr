---
phase: 03-web-ui
plan: 02
type: execute
wave: 2
depends_on: [03-01]
files_modified:
  - fetcharr/state.py
  - fetcharr/search/engine.py
  - fetcharr/search/scheduler.py
  - fetcharr/web/routes.py
  - fetcharr/templates/partials/app_card.html
  - fetcharr/templates/partials/search_log.html
  - fetcharr/static/css/output.css
autonomous: true
requirements: [WEBU-01, WEBU-02, WEBU-03, WEBU-04, WEBU-06]

must_haves:
  truths:
    - "AppState TypedDict includes connected, unreachable_since, missing_count, and cutoff_count fields"
    - "run_radarr_cycle stores raw item counts (before filtering) in state on successful fetch"
    - "run_sonarr_cycle stores raw item counts (before filtering) in state on successful fetch"
    - "On fetch failure, cycle functions set connected=False and unreachable_since (only if not already set)"
    - "On fetch success, cycle functions set connected=True and unreachable_since=None"
    - "Dashboard app card shows connection status indicator (green dot or red badge with unreachable timestamp)"
    - "Dashboard app card shows wanted and cutoff-unmet item counts"
    - "Dashboard app card shows last run time, next run time, and queue cursor positions"
    - "Search log displays most recent entries with app badge, item name, queue type, and timestamp"
  artifacts:
    - path: "fetcharr/state.py"
      provides: "Extended AppState with health and count fields"
      contains: "unreachable_since"
    - path: "fetcharr/search/engine.py"
      provides: "Cycle functions with connection health and item count tracking"
      contains: "missing_count"
    - path: "fetcharr/templates/partials/app_card.html"
      provides: "Complete dashboard card with all data points"
      contains: "unreachable_since"
  key_links:
    - from: "fetcharr/search/engine.py"
      to: "fetcharr/state.py"
      via: "Cycle functions write connected, unreachable_since, missing_count, cutoff_count to state"
      pattern: "missing_count|connected"
    - from: "fetcharr/web/routes.py"
      to: "fetcharr/state.py"
      via: "Partial routes read health and count fields from state for template context"
      pattern: "missing_count|connected"
---

<objective>
Add connection health tracking and item count caching to the search engine cycle functions, then update the dashboard templates and route handlers to display all required data points: connection status, item counts, last/next run, queue positions, and search history.

Purpose: Complete the dashboard's data layer so every field in the app card is backed by real data. After this plan, the dashboard is fully functional for read-only monitoring.

Output: Dashboard cards showing connection status (green dot or "unreachable since" badge), last/next run times, queue cursor positions, wanted/cutoff item counts, and a search log with app badges and timestamps.
</objective>

<execution_context>
@/Users/julianamacbook/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julianamacbook/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-web-ui/03-CONTEXT.md
@.planning/phases/03-web-ui/03-RESEARCH.md
@.planning/phases/03-web-ui/03-01-SUMMARY.md
@fetcharr/state.py
@fetcharr/search/engine.py
@fetcharr/search/scheduler.py
@fetcharr/web/routes.py
@fetcharr/templates/partials/app_card.html
@fetcharr/templates/partials/search_log.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add connection health and item count tracking to engine and state</name>
  <files>
    fetcharr/state.py
    fetcharr/search/engine.py
  </files>
  <action>
    **Update fetcharr/state.py:**
    Add four optional fields to `AppState`:
    ```python
    class AppState(TypedDict, total=False):
        missing_cursor: int
        cutoff_cursor: int
        last_run: str | None
        connected: bool | None          # True after successful fetch, False after failure
        unreachable_since: str | None    # ISO timestamp of first failure, None when healthy
        missing_count: int | None        # Total wanted-missing items (before filtering)
        cutoff_count: int | None         # Total cutoff-unmet items (before filtering)
    ```
    No changes to `_default_state()` — these fields are optional and default to None (absent from dict until first cycle runs).

    **Update fetcharr/search/engine.py — run_radarr_cycle:**
    In the `except` block (where fetch fails and the cycle aborts early):
    ```python
    except (httpx.HTTPStatusError, httpx.ConnectError, httpx.TimeoutException, httpx.HTTPError) as exc:
        logger.warning("Radarr: Cycle aborted -- {exc}", exc=exc)
        state["radarr"]["connected"] = False
        if not state["radarr"].get("unreachable_since"):
            state["radarr"]["unreachable_since"] = (
                datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")
            )
        return state
    ```

    After the successful fetch (immediately after `cutoff = await client.get_wanted_cutoff()`), before filtering:
    ```python
    # Track connection health (WEBU-06)
    state["radarr"]["connected"] = True
    state["radarr"]["unreachable_since"] = None

    # Cache raw item counts before filtering (WEBU-04)
    state["radarr"]["missing_count"] = len(missing)
    state["radarr"]["cutoff_count"] = len(cutoff)
    ```

    **Update fetcharr/search/engine.py — run_sonarr_cycle:**
    Same pattern. In the except block:
    ```python
    state["sonarr"]["connected"] = False
    if not state["sonarr"].get("unreachable_since"):
        state["sonarr"]["unreachable_since"] = (
            datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")
        )
    ```

    After successful fetch, before filtering:
    ```python
    state["sonarr"]["connected"] = True
    state["sonarr"]["unreachable_since"] = None
    state["sonarr"]["missing_count"] = len(missing_episodes)
    state["sonarr"]["cutoff_count"] = len(cutoff_episodes)
    ```

    Note: For Sonarr, `missing_count` and `cutoff_count` are RAW episode counts from the API (before filtering and deduplication). This matches what the *arr API reports as total wanted/cutoff items.
  </action>
  <verify>
    <automated>cd /Users/julianamacbook/fetcharr && python -c "
from fetcharr.state import AppState
# TypedDict fields should include new fields
import typing
hints = typing.get_type_hints(AppState)
assert 'connected' in hints, 'missing connected field'
assert 'unreachable_since' in hints, 'missing unreachable_since field'
assert 'missing_count' in hints, 'missing missing_count field'
assert 'cutoff_count' in hints, 'missing cutoff_count field'
print('AppState fields OK')

# Verify engine imports still work
from fetcharr.search.engine import run_radarr_cycle, run_sonarr_cycle
import inspect
radarr_src = inspect.getsource(run_radarr_cycle)
assert 'missing_count' in radarr_src, 'run_radarr_cycle missing count tracking'
assert 'connected' in radarr_src, 'run_radarr_cycle missing health tracking'
sonarr_src = inspect.getsource(run_sonarr_cycle)
assert 'missing_count' in sonarr_src, 'run_sonarr_cycle missing count tracking'
assert 'connected' in sonarr_src, 'run_sonarr_cycle missing health tracking'
print('Engine tracking OK')

# Existing tests still pass
print('ALL PASSED')
" && python -m pytest tests/ -x -q</automated>
  </verify>
  <done>AppState extended with connection health and item count fields. Both cycle functions track connected/unreachable_since on fetch success/failure and cache raw item counts before filtering. Existing tests still pass.</done>
</task>

<task type="auto">
  <name>Task 2: Update dashboard templates and routes with complete data</name>
  <files>
    fetcharr/web/routes.py
    fetcharr/templates/partials/app_card.html
    fetcharr/templates/partials/search_log.html
    fetcharr/static/css/output.css
  </files>
  <action>
    **Update fetcharr/web/routes.py:**
    Extend the app context dict (in `_build_app_context` or equivalent) to include the new fields from state:
    ```python
    app_data = {
        "name": app_name,
        "last_run": app_state.get("last_run"),
        "next_run": job.next_run_time.isoformat() if job and job.next_run_time else None,
        "missing_cursor": app_state.get("missing_cursor", 0),
        "cutoff_cursor": app_state.get("cutoff_cursor", 0),
        # NEW fields from Plan 02:
        "connected": app_state.get("connected"),        # True, False, or None (unknown)
        "unreachable_since": app_state.get("unreachable_since"),  # ISO string or None
        "missing_count": app_state.get("missing_count"),  # int or None
        "cutoff_count": app_state.get("cutoff_count"),    # int or None
    }
    ```
    Both the dashboard route and the `app-card` partial route must pass these fields.

    **Rewrite fetcharr/templates/partials/app_card.html:**
    Complete card layout matching CONTEXT decisions. Structure:

    ```html
    <div id="{{ app.name }}-card"
         hx-get="/partials/app-card/{{ app.name }}"
         hx-trigger="every 5s"
         hx-swap="outerHTML"
         class="bg-fetcharr-card rounded-lg border border-fetcharr-border p-5
                {% if app.connected == false %}border-l-4 border-l-red-500{% else %}border-l-4 border-l-fetcharr-green{% endif %}">
    ```

    Card header row:
    - App name capitalized (`{{ app.name | capitalize }}`) in `text-lg font-semibold`
    - Connection status indicator on the right side of the header:
      - If `app.connected` is `true` (Python True): green dot — a small `w-2.5 h-2.5 rounded-full bg-fetcharr-green` span
      - If `app.connected` is `false` (Python False): red badge showing "Unreachable since {time}" — format the ISO timestamp to a short human-readable form. Use Jinja2 inline: show just the date+time portion of the ISO string, e.g., `{{ app.unreachable_since[:19] | replace('T', ' ') }}` for simplicity.
      - If `app.connected` is `none` (Python None / not yet determined): gray dot or "Waiting..." in muted text

    Stats grid (use CSS grid or flex, 2 columns):
    - **Last Run**: `{{ app.last_run[:19] | replace('T', ' ') if app.last_run else 'Never' }}`
    - **Next Run**: `{{ app.next_run[:19] | replace('T', ' ') if app.next_run else '—' }}`
    - **Missing**: `{{ app.missing_count if app.missing_count is not none else '—' }} items` with `Position {{ app.missing_cursor }}`
    - **Cutoff**: `{{ app.cutoff_count if app.cutoff_count is not none else '—' }} items` with `Position {{ app.cutoff_cursor }}`

    Label styling: `text-xs uppercase tracking-wide text-fetcharr-muted`
    Value styling: `text-sm font-medium`

    Leave an empty div at the bottom for Plan 03 controls (enable/disable toggle, Search Now button).

    **Rewrite fetcharr/templates/partials/search_log.html:**
    Complete search log with proper formatting. Structure:

    ```html
    <div id="search-log"
         hx-get="/partials/search-log"
         hx-trigger="every 5s"
         hx-swap="outerHTML"
         class="bg-fetcharr-card rounded-lg border border-fetcharr-border p-5">
    ```

    Header: "Search Log" in `text-lg font-semibold mb-4`

    If search_log is empty: `<p class="text-fetcharr-muted text-sm">No searches yet.</p>`

    Otherwise, render entries newest-first (`search_log[::-1][:20]`) as a compact list:
    ```html
    {% for entry in search_log[::-1][:20] %}
    <div class="flex items-center gap-3 py-1.5 {% if not loop.last %}border-b border-fetcharr-border/50{% endif %}">
        <span class="text-xs font-medium px-2 py-0.5 rounded
               {% if entry.app == 'Radarr' %}bg-orange-500/20 text-orange-400
               {% else %}bg-blue-500/20 text-blue-400{% endif %}">
            {{ entry.app }}
        </span>
        <span class="text-sm flex-1 truncate">{{ entry.name }}</span>
        <span class="text-xs text-fetcharr-muted">{{ entry.queue_type }}</span>
        <span class="text-xs text-fetcharr-muted">{{ entry.timestamp[:19] | replace('T', ' ') }}</span>
    </div>
    {% endfor %}
    ```

    The app badges use Radarr's orange and Sonarr's blue to match their ecosystem branding, while the overall Fetcharr theme is green.

    **Recompile Tailwind CSS:**
    ```bash
    cd /Users/julianamacbook/fetcharr
    tailwindcss -i fetcharr/static/css/input.css -o fetcharr/static/css/output.css --minify
    ```
    This picks up any new Tailwind classes used in updated templates.
  </action>
  <verify>
    <automated>cd /Users/julianamacbook/fetcharr && python -c "
from pathlib import Path

# Check app_card template has health and count display
card = Path('fetcharr/templates/partials/app_card.html').read_text()
assert 'connected' in card, 'Card missing connection status'
assert 'missing_count' in card or 'missing' in card.lower(), 'Card missing item counts'
assert 'unreachable_since' in card, 'Card missing unreachable indicator'
print('App card template OK')

# Check search log template has app badges
log = Path('fetcharr/templates/partials/search_log.html').read_text()
assert 'entry.app' in log or 'Radarr' in log, 'Search log missing app reference'
assert 'entry.name' in log, 'Search log missing item name'
print('Search log template OK')

# Check routes pass new fields
import inspect
from fetcharr.web.routes import app_card_partial
src = inspect.getsource(app_card_partial)
assert 'connected' in src or 'missing_count' in src or '_build_app_context' in src, 'Route missing new fields'
print('Routes updated OK')

print('ALL PASSED')
" && python -m pytest tests/ -x -q</automated>
  </verify>
  <done>Dashboard cards show complete data: connection status (green/red indicator with unreachable timestamp), last/next run times, item counts, queue positions. Search log shows color-coded app badges (orange=Radarr, blue=Sonarr) with names, types, and timestamps. All existing tests pass.</done>
</task>

</tasks>

<verification>
- `python -m pytest tests/ -v` passes (all existing tests)
- App card template references `connected`, `unreachable_since`, `missing_count`, `cutoff_count`
- Search log template renders entries with app badges and timestamps
- Both cycle functions include health tracking (`connected`, `unreachable_since`) and count caching (`missing_count`, `cutoff_count`)
</verification>

<success_criteria>
- WEBU-01: Dashboard shows last run time and next scheduled run per app
- WEBU-02: Dashboard shows recent search history with item names and timestamps
- WEBU-03: Dashboard shows current round-robin queue position per app
- WEBU-04: Dashboard shows wanted and cutoff unmet item counts per app
- WEBU-06: Dashboard shows connection status with "unreachable since" when *arr is down
- AppState TypedDict updated with health and count fields
- Cycle functions update state with counts and health on every execution
- Existing Phase 1 and Phase 2 tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-web-ui/03-02-SUMMARY.md`
</output>
