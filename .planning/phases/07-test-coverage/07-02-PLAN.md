---
phase: 07-test-coverage
plan: 02
type: execute
wave: 2
depends_on:
  - "07-01"
files_modified:
  - tests/test_search.py
  - tests/test_scheduler.py
  - tests/test_startup.py
autonomous: true
requirements:
  - QUAL-07

must_haves:
  truths:
    - "run_radarr_cycle happy path fetches items, searches, advances cursors, and updates last_run"
    - "run_radarr_cycle network failure aborts cycle, sets connected=False, preserves cursors"
    - "run_radarr_cycle per-item search failure skips that item and continues to next"
    - "run_radarr_cycle advances cursors correctly after processing a batch"
    - "run_sonarr_cycle happy path fetches episodes, deduplicates to seasons, searches, and advances cursors"
    - "run_sonarr_cycle network failure aborts cycle, sets connected=False, preserves cursors"
    - "run_sonarr_cycle per-item search failure skips that item and continues to next"
    - "run_sonarr_cycle advances cursors correctly after processing a batch"
    - "make_search_job returns early without error when client is None"
    - "make_search_job catches and swallows unhandled exceptions from cycle function"
    - "collect_secrets extracts all non-empty API keys from settings"
  artifacts:
    - path: "tests/test_search.py"
      provides: "Async cycle function tests (8 new tests added to existing file)"
      contains: "run_radarr_cycle"
    - path: "tests/test_scheduler.py"
      provides: "make_search_job tests (2 tests in new file)"
      contains: "make_search_job"
    - path: "tests/test_startup.py"
      provides: "collect_secrets test (1 new test added to existing file)"
      contains: "collect_secrets"
  key_links:
    - from: "tests/test_search.py"
      to: "fetcharr/search/engine.py"
      via: "AsyncMock patching of client methods"
      pattern: "AsyncMock"
    - from: "tests/test_scheduler.py"
      to: "fetcharr/search/scheduler.py"
      via: "FastAPI app.state mocking with AsyncMock clients"
      pattern: "make_search_job"
    - from: "tests/test_startup.py"
      to: "fetcharr/startup.py"
      via: "Direct function call with Settings instance"
      pattern: "collect_secrets"
---

<objective>
Add async test coverage for search cycle orchestrators (`run_radarr_cycle`, `run_sonarr_cycle`), the scheduler job factory (`make_search_job`), and the startup utility (`collect_secrets`).

Purpose: These 11 tests cover the higher-level orchestration layer -- cycle functions that compose pure utilities with API client calls, the scheduler job wrapper, and the secret collection utility. This addresses success criteria 4-6 of QUAL-07.

Output: Updated `tests/test_search.py` with 8 new async tests, new `tests/test_scheduler.py` with 2 tests, updated `tests/test_startup.py` with 1 new test.
</objective>

<execution_context>
@/Users/julianamacbook/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julianamacbook/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-test-coverage/07-RESEARCH.md
@.planning/phases/07-test-coverage/07-01-SUMMARY.md

@fetcharr/search/engine.py
@fetcharr/search/scheduler.py
@fetcharr/startup.py
@fetcharr/state.py
@fetcharr/models/config.py
@tests/conftest.py
@tests/test_search.py
@tests/test_startup.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add async cycle function tests to test_search.py</name>
  <files>tests/test_search.py</files>
  <action>
Append 8 new async test functions to the existing `tests/test_search.py`. These test the orchestration logic of `run_radarr_cycle` and `run_sonarr_cycle` by mocking client methods with `AsyncMock`. Add imports at top: `from unittest.mock import AsyncMock`, `import httpx`, `from fetcharr.search.engine import run_radarr_cycle, run_sonarr_cycle`. Import `make_settings` from `conftest` (or use local helper) and `_default_state` from `fetcharr.state`.

Use a local `_make_settings` helper (or import from conftest) that creates a `Settings` with both apps enabled, `search_missing_count=2`, `search_cutoff_count=2` for predictable batching.

**run_radarr_cycle tests (4 tests):**

1. `test_run_radarr_cycle_happy_path`:
   - `client.get_wanted_missing` returns `[{"id": 1, "title": "Movie A", "monitored": True}, {"id": 2, "title": "Movie B", "monitored": True}]`
   - `client.get_wanted_cutoff` returns `[]` (empty cutoff)
   - `client.search_movies` is an `AsyncMock()`
   - Assert `search_movies` was called with `[1]` then `[2]` (batch_size=2 means both get searched)
   - Assert `state["radarr"]["last_run"]` is not None
   - Assert `state["radarr"]["connected"]` is True
   - Assert `state["radarr"]["missing_cursor"]` wrapped to 0 (2 items, batch 2, cursor wraps)

2. `test_run_radarr_cycle_network_failure`:
   - `client.get_wanted_missing` raises `httpx.ConnectError("refused")`
   - State starts with `missing_cursor=5`
   - Assert `state["radarr"]["connected"]` is False
   - Assert `state["radarr"]["unreachable_since"]` is not None
   - Assert `state["radarr"]["missing_cursor"]` is still 5 (unchanged)

3. `test_run_radarr_cycle_per_item_skip`:
   - `client.get_wanted_missing` returns 2 movies (both monitored)
   - `client.get_wanted_cutoff` returns `[]`
   - `client.search_movies` side_effect: first call raises `Exception("boom")`, second call succeeds
   - Assert `search_movies` was called twice (didn't abort after first failure)
   - Assert search_log has 1 entry (only the successful search was logged)

4. `test_run_radarr_cycle_cursor_advancement`:
   - `client.get_wanted_missing` returns 5 movies (all monitored), `client.get_wanted_cutoff` returns `[]`
   - Settings: `search_missing_count=2`
   - State starts with `missing_cursor=0`
   - Assert `state["radarr"]["missing_cursor"]` is 2 after cycle (advanced by batch_size)
   - Run again with cursor at 2 -> assert cursor is 4
   - Run again with cursor at 4 -> assert cursor wraps to 0

**run_sonarr_cycle tests (4 tests):**

5. `test_run_sonarr_cycle_happy_path`:
   - `client.get_wanted_missing` returns 2 episodes from same series different seasons (monitored, past air date, with `series.title`)
   - `client.get_wanted_cutoff` returns `[]`
   - `client.search_season` is an `AsyncMock()`
   - Assert `search_season` was called with correct seriesId and seasonNumber
   - Assert `state["sonarr"]["connected"]` is True

6. `test_run_sonarr_cycle_network_failure`:
   - `client.get_wanted_missing` raises `httpx.ConnectError("refused")`
   - State starts with `missing_cursor=3`
   - Assert `state["sonarr"]["connected"]` is False
   - Assert `state["sonarr"]["missing_cursor"]` is still 3

7. `test_run_sonarr_cycle_per_item_skip`:
   - `client.get_wanted_missing` returns 2 episodes from different series (to produce 2 seasons after dedup)
   - `client.get_wanted_cutoff` returns `[]`
   - `client.search_season` side_effect: first raises `Exception("boom")`, second succeeds
   - Assert `search_season` called twice
   - Assert search_log has 1 entry

8. `test_run_sonarr_cycle_cursor_advancement`:
   - Similar to radarr cursor test but with Sonarr episode data
   - 4 episodes deduplicating to 3 seasons, `search_missing_count=2`
   - Assert cursor advances by 2 on first cycle, then wraps correctly

**For all cycle tests:**
- Create a fresh `_default_state()` per test
- Client is `AsyncMock()` with methods set as `AsyncMock(return_value=...)` or `AsyncMock(side_effect=...)`
- All episodes must have `airDateUtc` set to a past date (e.g. `"2020-01-01T00:00:00Z"`) and `monitored: True` to pass filtering
- Do NOT use `@pytest.mark.asyncio` (auto mode)
  </action>
  <verify>
    <automated>python3 -c "import ast; tree = ast.parse(open('tests/test_search.py').read()); funcs = [n.name for n in ast.walk(tree) if isinstance(n, (ast.FunctionDef, ast.AsyncFunctionDef)) and n.name.startswith('test_')]; print(f'{len(funcs)} tests'); assert len(funcs) >= 27, f'Expected >= 27 tests, got {len(funcs)}'"</automated>
    <manual>Verify 19 existing tests + 8 new async cycle tests = 27+ test functions</manual>
  </verify>
  <done>test_search.py has 8 new async tests covering run_radarr_cycle (4) and run_sonarr_cycle (4) with happy path, network failure, per-item skip, and cursor advancement</done>
</task>

<task type="auto">
  <name>Task 2: Create test_scheduler.py and add collect_secrets test to test_startup.py</name>
  <files>
    tests/test_scheduler.py
    tests/test_startup.py
  </files>
  <action>
**Create `tests/test_scheduler.py` (new file, 2 tests):**

Import: `asyncio`, `from pathlib import Path`, `from unittest.mock import AsyncMock, patch, MagicMock`, `from fastapi import FastAPI`, `from fetcharr.search.scheduler import make_search_job`, `from fetcharr.state import _default_state`. Import `make_settings` from `conftest` (or define a local helper).

1. `test_make_search_job_client_none_returns_early`:
   - Create `FastAPI()` instance
   - Set `app.state.radarr_client = None`
   - Set `app.state.search_lock = asyncio.Lock()`
   - Call `make_search_job(app, "radarr", Path("/tmp/state.json"))` to get job closure
   - `await job()` -- should return without error and without accessing other state attributes
   - No assertion on cycle function (it should never be called)

2. `test_make_search_job_exception_swallowed`:
   - Create `FastAPI()` instance
   - Set `app.state.radarr_client = AsyncMock()`
   - Set `app.state.search_lock = asyncio.Lock()`
   - Set `app.state.fetcharr_state = _default_state()`
   - Set `app.state.settings = make_settings()` (from conftest or local helper)
   - Patch `fetcharr.search.scheduler.run_radarr_cycle` with `AsyncMock(side_effect=RuntimeError("boom"))`
   - Patch `fetcharr.search.scheduler.save_state` as `MagicMock()` (prevent file I/O)
   - Call `make_search_job(app, "radarr", Path("/tmp/state.json"))` to get job closure
   - `await job()` -- should NOT raise (exception is caught internally)
   - The test passes if no exception propagates

**Add 1 test to `tests/test_startup.py`:**

Add import of `collect_secrets` from `fetcharr.startup` (may already be imported if only `check_localhost_urls` is there -- add `collect_secrets` to the import).

3. `test_collect_secrets_extracts_all_api_keys`:
   - Use the existing `_make_settings` helper already in test_startup.py (it creates Settings with `api_key="test-key"` for both apps)
   - Modify to pass different keys: create settings with `radarr api_key="radarr-secret"` and `sonarr api_key="sonarr-secret"` using a one-off settings construction
   - Call `collect_secrets(settings)`
   - Assert `"radarr-secret"` in result
   - Assert `"sonarr-secret"` in result
   - Assert `len(result) == 2`
   - This is a sync test (collect_secrets is not async)
  </action>
  <verify>
    <automated>python3 -c "import ast; tree1 = ast.parse(open('tests/test_scheduler.py').read()); tree2 = ast.parse(open('tests/test_startup.py').read()); f1 = [n.name for n in ast.walk(tree1) if isinstance(n, (ast.FunctionDef, ast.AsyncFunctionDef)) and n.name.startswith('test_')]; f2 = [n.name for n in ast.walk(tree2) if isinstance(n, (ast.FunctionDef, ast.AsyncFunctionDef)) and n.name.startswith('test_')]; print(f'scheduler: {len(f1)}, startup: {len(f2)}'); assert len(f1) >= 2; assert len(f2) >= 6"</automated>
    <manual>test_scheduler.py has 2 tests; test_startup.py has 5 existing + 1 new = 6+ tests</manual>
  </verify>
  <done>test_scheduler.py created with 2 make_search_job tests; test_startup.py has 1 new collect_secrets test; all success criteria 4-6 of QUAL-07 addressed</done>
</task>

</tasks>

<verification>
- `tests/test_search.py` has 8 new async tests for cycle functions (4 radarr + 4 sonarr)
- `tests/test_scheduler.py` exists with 2 tests for make_search_job (client-None + exception swallowing)
- `tests/test_startup.py` has 1 new test for collect_secrets
- All cycle tests use `AsyncMock` for client method patching (not MockTransport)
- Each test creates a fresh `_default_state()` (no shared mutable state)
- No new dependencies added
- Tests follow `asyncio_mode = "auto"` convention
</verification>

<success_criteria>
- 11 new tests added across 3 files covering cycle orchestration, scheduler, and secret collection
- AST parse succeeds for all modified/created files
- Success criteria 4-6 of QUAL-07 addressed
- Total new tests across both plans: 22 (11 client + 11 orchestration)
</success_criteria>

<output>
After completion, create `.planning/phases/07-test-coverage/07-02-SUMMARY.md`
</output>
