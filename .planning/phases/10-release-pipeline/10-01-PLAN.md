---
phase: 10-release-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [.github/workflows/release.yml, CLAUDE.md]
autonomous: true
requirements: [RELS-01, RELS-02, RELS-03]

must_haves:
  truths:
    - "Pushing to main triggers a workflow that builds and pushes ghcr.io/thejuran/fetcharr:dev"
    - "Pushing a version tag (v*.*.*) triggers a workflow that builds and pushes both :latest and the version-tagged image"
    - "CLAUDE.md exists at the project root and describes the deep code review convention"
    - "The release workflow uses the same Dockerfile already in the repo (no duplicate build logic)"
  artifacts:
    - path: ".github/workflows/release.yml"
      provides: "Docker image build and push workflow for dev and release tags"
      contains: "ghcr.io/thejuran/fetcharr"
    - path: "CLAUDE.md"
      provides: "Project conventions including deep code review"
      contains: "deep-review"
  key_links:
    - from: ".github/workflows/release.yml"
      to: "Dockerfile"
      via: "docker/build-push-action uses the repo Dockerfile"
      pattern: "build-push-action"
    - from: ".github/workflows/release.yml"
      to: "ghcr.io/thejuran/fetcharr"
      via: "image tags in push step"
      pattern: "ghcr\\.io/thejuran/fetcharr"
---

<objective>
Create the release pipeline that automatically publishes Docker images to GHCR, and document the deep code review convention in CLAUDE.md.

Purpose: Automate image delivery so every main push produces a :dev image and every version tag produces :latest + versioned images, eliminating manual docker build/push. Document the review convention so Claude always offers /deep-review before push.
Output: .github/workflows/release.yml, CLAUDE.md
</objective>

<execution_context>
@/Users/julianamacbook/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julianamacbook/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.github/workflows/ci.yml
@Dockerfile
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GitHub Actions release workflow for GHCR publishing</name>
  <files>.github/workflows/release.yml</files>
  <action>
Create `.github/workflows/release.yml` with two trigger paths:

**Triggers:**
- `push.branches: [main]` — builds and pushes `:dev` tag
- `push.tags: ['v*.*.*']` — builds and pushes `:latest` and the version tag (e.g., `:v1.1.0`)

**Workflow structure (single job `release`):**

1. `actions/checkout@v4`
2. `docker/setup-buildx-action@v3` — enables BuildKit layer caching
3. `docker/login-action@v3` — authenticate to ghcr.io using `registry: ghcr.io`, `username: ${{ github.actor }}`, `password: ${{ secrets.GITHUB_TOKEN }}`
4. `docker/metadata-action@v5` — compute image tags:
   - For main push: `type=raw,value=dev`
   - For version tag push: `type=raw,value=latest` and `type=ref,event=tag`
5. `docker/build-push-action@v6` — build using repo `Dockerfile`, push=true, tags from metadata step, labels from metadata step

**Permissions:** Set `packages: write` and `contents: read` at job level so GITHUB_TOKEN can push to GHCR.

Use `if: github.event_name == 'push'` on the job to ensure it only runs on push (not PR). The workflow should NOT run on pull_request — only push events.

Do NOT duplicate any build logic from the Dockerfile. The workflow just invokes `docker build` on the existing Dockerfile.
  </action>
  <verify>
    <automated>cat .github/workflows/release.yml | grep -c "ghcr.io" && cat .github/workflows/release.yml | grep -c "build-push-action"</automated>
    <manual>Verify workflow references ghcr.io/thejuran/fetcharr, has both main and tag triggers, and uses docker/build-push-action</manual>
  </verify>
  <done>release.yml exists with push-to-main triggering :dev tag and version tag triggering :latest + version tag, both pushing to ghcr.io/thejuran/fetcharr</done>
</task>

<task type="auto">
  <name>Task 2: Create CLAUDE.md with deep code review convention</name>
  <files>CLAUDE.md</files>
  <action>
Create `CLAUDE.md` at the project root with the following sections:

**Project overview** (2-3 lines): Fetcharr is a Python automation daemon that triggers searches in Radarr and Sonarr on a schedule. FastAPI + htmx + Tailwind CSS v4 dark UI. Docker-first deployment to ghcr.io/thejuran/fetcharr.

**Development commands:**
- `uv sync --extra dev` — install dependencies
- `uv run pytest tests/ -x -q` — run tests
- `uv run ruff check fetcharr/ tests/` — lint
- `uv run tailwindcss -i fetcharr/static/css/input.css -o fetcharr/static/css/output.css --watch` — dev CSS
- `docker build -t fetcharr:local .` — local Docker build

**Code conventions:**
- Python 3.11+, ruff linting (E, F, I, UP, B, SIM), line length 120
- SecretStr for all API keys — call .get_secret_value() only at HTTP client init
- Loguru for logging with custom redacting sink (never print/logging module)
- Atomic file writes (write-then-rename) for config and state
- pytest-asyncio with asyncio_mode=auto

**Deep Code Review Convention:**
Before pushing to main or creating a release tag, offer `/deep-review` to the user. The deep review checks:
1. Security: No API keys in logs, responses, or HTML. SecretStr discipline maintained.
2. Correctness: All tests pass (`pytest tests/ -x`). No ruff violations.
3. Resilience: Error handling follows established patterns (httpx.HTTPError + pydantic.ValidationError catches). No bare `except:`.
4. Docker: Dockerfile builds successfully. No secrets baked into image layers.
5. Config: Pydantic validation before any config write. TOML comments preserved in defaults.

State: "Before pushing, I recommend running /deep-review to check for security, correctness, and resilience issues. Shall I proceed?"

Keep the file concise — under 60 lines. This is a working reference, not documentation.
  </action>
  <verify>
    <automated>test -f CLAUDE.md && grep -c "deep-review" CLAUDE.md</automated>
    <manual>Verify CLAUDE.md contains project overview, dev commands, code conventions, and the deep review convention</manual>
  </verify>
  <done>CLAUDE.md exists at project root, contains deep code review convention that instructs Claude to offer /deep-review before push</done>
</task>

</tasks>

<verification>
1. `.github/workflows/release.yml` exists and is valid YAML
2. Workflow triggers on push to main AND push of version tags (v*.*.*)
3. Workflow authenticates to ghcr.io and uses docker/build-push-action
4. Main push produces `:dev` tag, version tag push produces `:latest` + version tag
5. `CLAUDE.md` exists and contains the deep code review convention with `/deep-review`
6. No changes to existing `ci.yml` — release workflow is separate
</verification>

<success_criteria>
- release.yml is syntactically valid and references ghcr.io/thejuran/fetcharr with correct tag strategies
- CLAUDE.md is under 60 lines and contains actionable deep-review convention
- Existing CI workflow (ci.yml) is untouched
</success_criteria>

<output>
After completion, create `.planning/phases/10-release-pipeline/10-01-SUMMARY.md`
</output>
