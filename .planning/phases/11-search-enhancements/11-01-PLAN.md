---
phase: 11-search-enhancements
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - fetcharr/models/config.py
  - fetcharr/config.py
  - fetcharr/search/engine.py
  - fetcharr/web/routes.py
  - fetcharr/web/validation.py
  - fetcharr/templates/settings.html
  - tests/test_search.py
autonomous: true
requirements:
  - SRCH-12

must_haves:
  truths:
    - "User can configure a hard_max_per_cycle value in TOML config under [general]"
    - "hard_max_per_cycle caps total items searched per cycle across both missing and cutoff queues"
    - "hard_max_per_cycle is visible and editable in the web UI settings page with validation (1-1000, default 0=unlimited)"
    - "When hard_max_per_cycle is 0 or unset, per-app counts apply unchanged (backwards compatible)"
    - "When hard_max_per_cycle is set, each app's per-cycle totals (missing + cutoff) are capped at this value"
  artifacts:
    - path: "fetcharr/models/config.py"
      provides: "hard_max_per_cycle field on GeneralConfig"
      contains: "hard_max_per_cycle"
    - path: "fetcharr/search/engine.py"
      provides: "Cap logic applying hard_max_per_cycle to batch sizes"
      contains: "hard_max_per_cycle"
    - path: "fetcharr/templates/settings.html"
      provides: "Hard max input field in General section"
      contains: "hard_max_per_cycle"
    - path: "tests/test_search.py"
      provides: "Tests for hard max cap logic"
      contains: "hard_max"
  key_links:
    - from: "fetcharr/search/engine.py"
      to: "fetcharr/models/config.py"
      via: "settings.general.hard_max_per_cycle"
      pattern: "settings\\.general\\.hard_max_per_cycle"
    - from: "fetcharr/web/routes.py"
      to: "fetcharr/models/config.py"
      via: "settings.general.hard_max_per_cycle read for template context"
      pattern: "hard_max_per_cycle"
    - from: "fetcharr/templates/settings.html"
      to: "fetcharr/web/routes.py"
      via: "form field name matching route handler"
      pattern: "hard_max_per_cycle"
---

<objective>
Add a global hard_max_per_cycle safety ceiling to limit total items searched per cycle per app, with config, engine integration, UI editing, and tests.

Purpose: Prevents runaway search volume on large libraries. Users with 10,000+ wanted items need a safety cap that overrides the per-queue counts.
Output: Working hard max feature with config field, engine cap logic, settings UI field, and test coverage.
</objective>

<execution_context>
@/Users/julianamacbook/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julianamacbook/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@fetcharr/models/config.py
@fetcharr/search/engine.py
@fetcharr/config.py
@fetcharr/web/routes.py
@fetcharr/web/validation.py
@fetcharr/templates/settings.html
@tests/test_search.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add hard_max_per_cycle to config and engine</name>
  <files>
    fetcharr/models/config.py
    fetcharr/config.py
    fetcharr/search/engine.py
  </files>
  <action>
1. In `fetcharr/models/config.py`, add `hard_max_per_cycle: int = 0` to `GeneralConfig`. Value 0 means unlimited (no cap). Must be >= 0.

2. In `fetcharr/config.py`, add the new field to `DEFAULT_CONFIG` template under `[general]` section as a commented-out line:
   ```
   # hard_max_per_cycle = 0   # 0 = unlimited; caps total items searched per app per cycle
   ```

3. In `fetcharr/search/engine.py`, add a helper function `apply_hard_max(missing_count: int, cutoff_count: int, hard_max: int) -> tuple[int, int]` that:
   - If `hard_max <= 0`, returns (missing_count, cutoff_count) unchanged
   - Otherwise, caps the total (missing + cutoff) to hard_max, distributing proportionally but ensuring at least 1 for each queue if both are > 0. Simple approach: missing gets min(missing_count, hard_max), then cutoff gets min(cutoff_count, hard_max - actual_missing). If missing already uses all of hard_max, cutoff gets 0.
   - Actually, simplest correct approach: total = missing_count + cutoff_count. If total <= hard_max, return unchanged. Otherwise, half = hard_max // 2. Give missing min(missing_count, half), give cutoff min(cutoff_count, hard_max - actual_missing_allocated).

   Simpler design: just cap each queue's batch size BEFORE slicing. In `run_radarr_cycle` and `run_sonarr_cycle`, after getting settings.radarr.search_missing_count and search_cutoff_count, compute effective counts:
   ```python
   hard_max = settings.general.hard_max_per_cycle
   missing_limit = settings.radarr.search_missing_count
   cutoff_limit = settings.radarr.search_cutoff_count
   if hard_max > 0:
       # Split hard_max between missing and cutoff, proportionally
       total_requested = missing_limit + cutoff_limit
       if total_requested > hard_max:
           # Proportional split, round down, ensure at least 0
           missing_limit = max(0, (missing_limit * hard_max) // total_requested)
           cutoff_limit = hard_max - missing_limit
   ```

   Apply this logic at the top of each cycle function (run_radarr_cycle and run_sonarr_cycle), right before the "Missing queue" section. Extract it into a pure function `cap_batch_sizes(missing_count: int, cutoff_count: int, hard_max: int) -> tuple[int, int]` for testability.

   Log when cap is applied: `logger.debug("{app}: Hard max {max} applied -- missing={m}, cutoff={c}", ...)`
  </action>
  <verify>
    <automated>cd /Users/julianamacbook/fetcharr && uv run python -c "from fetcharr.models.config import GeneralConfig; g = GeneralConfig(); assert g.hard_max_per_cycle == 0; print('OK')" && uv run python -c "from fetcharr.search.engine import cap_batch_sizes; assert cap_batch_sizes(5, 5, 0) == (5, 5); assert cap_batch_sizes(5, 5, 6) == (3, 3); assert cap_batch_sizes(5, 5, 10) == (5, 5); print('OK')"</automated>
  </verify>
  <done>GeneralConfig has hard_max_per_cycle field defaulting to 0. cap_batch_sizes function exists and correctly caps proportionally. Both cycle functions call it before slicing batches. DEFAULT_CONFIG includes commented field.</done>
</task>

<task type="auto">
  <name>Task 2: Add hard max to settings UI and write tests</name>
  <files>
    fetcharr/web/routes.py
    fetcharr/web/validation.py
    fetcharr/templates/settings.html
    tests/test_search.py
  </files>
  <action>
1. In `fetcharr/web/routes.py`, in the `settings_page` GET handler, add `hard_max_per_cycle` to the template context:
   ```python
   "hard_max_per_cycle": settings.general.hard_max_per_cycle,
   ```

2. In `fetcharr/web/routes.py`, in the `save_settings` POST handler, read the form field and include it in `new_config["general"]`:
   ```python
   "hard_max_per_cycle": safe_int(form.get("hard_max_per_cycle"), 0, 0, 1000),
   ```
   Note: use 0 as default (unlimited), min 0, max 1000.

3. In `fetcharr/templates/settings.html`, add a field to the General section (after log_level) for hard_max_per_cycle:
   ```html
   <div>
       <label class="block text-sm text-fetcharr-muted mb-1">Hard Max Items Per Cycle</label>
       <input type="number" name="hard_max_per_cycle" value="{{ hard_max_per_cycle }}"
              min="0" max="1000"
              class="w-full bg-fetcharr-bg border border-fetcharr-border rounded px-3 py-2 text-sm">
       <p class="text-xs text-fetcharr-muted mt-1">0 = unlimited. Caps total items per app per cycle.</p>
   </div>
   ```

4. In `tests/test_search.py`, add tests for `cap_batch_sizes`:
   - `test_cap_batch_sizes_unlimited`: hard_max=0 returns inputs unchanged
   - `test_cap_batch_sizes_no_cap_needed`: total within limit returns unchanged
   - `test_cap_batch_sizes_proportional_split`: total exceeds limit, verify proportional reduction
   - `test_cap_batch_sizes_one_zero`: one queue is 0, other gets full cap
   - `test_cap_batch_sizes_very_small_max`: hard_max=1, verify at least one gets searched
  </action>
  <verify>
    <automated>cd /Users/julianamacbook/fetcharr && uv run pytest tests/test_search.py -x -q -k "hard_max or cap_batch"</automated>
  </verify>
  <done>Settings page shows hard_max_per_cycle field in General section. Saving settings persists the value. 5+ tests cover cap_batch_sizes edge cases and all pass.</done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/ -x -q` -- all existing + new tests pass
2. `uv run ruff check fetcharr/ tests/` -- no lint violations
3. Import check: `uv run python -c "from fetcharr.search.engine import cap_batch_sizes; print('OK')"`
</verification>

<success_criteria>
- GeneralConfig has hard_max_per_cycle: int = 0
- cap_batch_sizes pure function exists in engine.py with proportional split logic
- Both run_radarr_cycle and run_sonarr_cycle call cap_batch_sizes before slicing
- Settings UI displays and saves the hard_max_per_cycle value
- DEFAULT_CONFIG template includes commented hard_max_per_cycle
- Tests cover unlimited (0), no-cap-needed, proportional split, edge cases
- All tests pass, no ruff violations
</success_criteria>

<output>
After completion, create `.planning/phases/11-search-enhancements/11-01-SUMMARY.md`
</output>
