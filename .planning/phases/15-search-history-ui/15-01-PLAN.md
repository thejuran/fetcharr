---
phase: 15-search-history-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - fetcharr/db.py
  - fetcharr/web/routes.py
  - fetcharr/templates/base.html
  - fetcharr/templates/history.html
  - fetcharr/templates/partials/history_results.html
autonomous: true
requirements: [SRCH-14]

must_haves:
  truths:
    - "User can navigate to /history from the nav bar"
    - "History page displays search entries with app badge, item name, queue type, outcome badge, and timestamp"
    - "User can filter by app (Radarr/Sonarr), queue type (missing/cutoff), and outcome (searched/failed) via toggle pills"
    - "User can search by item name via text input"
    - "Results paginate at 50 per page with prev/next and page number controls"
    - "Empty state shows informative message when no history exists"
    - "Filter changes and pagination use htmx partial swaps without full page reloads"
  artifacts:
    - path: "fetcharr/db.py"
      provides: "get_search_history query with filter and pagination"
      contains: "def get_search_history"
    - path: "fetcharr/web/routes.py"
      provides: "/history page route and /partials/history-results partial route"
      contains: "history_page"
    - path: "fetcharr/templates/base.html"
      provides: "History nav link between Dashboard and Settings"
      contains: "History"
    - path: "fetcharr/templates/history.html"
      provides: "Search History full page template"
      contains: "Search History"
    - path: "fetcharr/templates/partials/history_results.html"
      provides: "Filter bar, results table, and pagination partial"
      contains: "history-results"
  key_links:
    - from: "fetcharr/templates/history.html"
      to: "/partials/history-results"
      via: "htmx include of partial on page load"
      pattern: "hx-get.*partials/history-results"
    - from: "fetcharr/templates/partials/history_results.html"
      to: "/partials/history-results"
      via: "htmx filter pill clicks and pagination links"
      pattern: "hx-get.*partials/history-results"
    - from: "fetcharr/web/routes.py"
      to: "fetcharr/db.py"
      via: "partial_history_results calls get_search_history"
      pattern: "get_search_history"
---

<objective>
Build the search history page backend and frontend: a paginated, filterable view of all search history entries accessible from the nav bar.

Purpose: Users currently only see the 20 most recent searches on the dashboard. This gives them browsable access to the full 500-entry search history with filtering by app, queue type, outcome, and item name.

Output: Working /history page with filter bar, paginated results, and htmx partial swaps.
</objective>

<execution_context>
@/Users/julianamacbook/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julianamacbook/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-search-history-ui/15-CONTEXT.md

@fetcharr/db.py
@fetcharr/web/routes.py
@fetcharr/templates/base.html
@fetcharr/templates/partials/search_log.html
@fetcharr/templates/dashboard.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Backend query function and routes</name>
  <files>
    fetcharr/db.py
    fetcharr/web/routes.py
  </files>
  <action>
**db.py — Add `get_search_history()` function:**

Add a new async function `get_search_history` below the existing `get_recent_searches` function. Signature:

```python
async def get_search_history(
    db_path: Path,
    *,
    page: int = 1,
    per_page: int = 50,
    app_filter: list[str] | None = None,
    queue_filter: list[str] | None = None,
    outcome_filter: list[str] | None = None,
    search_text: str = "",
) -> dict:
```

Implementation:
- Build a WHERE clause dynamically from the filter parameters. `app_filter` filters on `app` column (values: "Radarr", "Sonarr"). `queue_filter` filters on `queue_type` column (values: "missing", "cutoff"). `outcome_filter` filters on `outcome` column (values: "searched", "failed"). `search_text` does a `LIKE %text%` match on `item_name` column (case-insensitive via SQLite LIKE).
- None or empty list for any filter means "no filter on that column" (return all).
- Run a COUNT(*) query with the same WHERE clause to get `total_count`.
- Run a SELECT query with `ORDER BY id DESC`, `LIMIT per_page`, `OFFSET (page - 1) * per_page`.
- Return a dict:
  ```python
  {
      "entries": [...],  # list of dicts same shape as get_recent_searches
      "total": total_count,
      "page": page,
      "per_page": per_page,
      "total_pages": math.ceil(total_count / per_page) or 1,
  }
  ```
- Import `math` at the top of the file.
- Each entry dict has keys: name, timestamp, app, queue_type, outcome, detail, id (include the row id for display).
- Use parameterized queries (?) for all filter values — no string interpolation for SQL injection safety.

**routes.py — Add history page route and partial:**

Add import for `get_search_history` from `fetcharr.db`.

Add route `GET /history`:
```python
@router.get("/history", response_class=HTMLResponse)
async def history_page(request: Request) -> HTMLResponse:
```
- Call `get_search_history(request.app.state.db_path)` with default params to get initial page data.
- Render `history.html` template with context: `{"result": result}`.

Add route `GET /partials/history-results`:
```python
@router.get("/partials/history-results", response_class=HTMLResponse)
async def partial_history_results(request: Request) -> HTMLResponse:
```
- Parse query params from `request.query_params`:
  - `page` (int, default 1)
  - `app` (comma-separated string, e.g. "Radarr,Sonarr" — split into list, or None if absent/empty)
  - `queue` (comma-separated string, e.g. "missing,cutoff" — split into list, or None if absent/empty)
  - `outcome` (comma-separated string, e.g. "searched,failed" — split into list, or None if absent/empty)
  - `search` (string, default "")
- Call `get_search_history()` with these params.
- Render `partials/history_results.html` template with context including the result dict and the current filter values (so pills can show active state).
- Context should include: `result` (the dict), `active_apps` (list), `active_queues` (list), `active_outcomes` (list), `search_text` (str).
  </action>
  <verify>
    <automated>cd /Users/julianamacbook/fetcharr && uv run python -c "from fetcharr.db import get_search_history; from fetcharr.web.routes import history_page, partial_history_results; print('imports ok')"</automated>
    <manual>Verify function signature and SQL parameterization in db.py</manual>
  </verify>
  <done>
    - get_search_history function exists in db.py with filtering, pagination, and total count
    - /history route renders history.html template
    - /partials/history-results route parses query params and renders partial
    - All SQL uses parameterized queries (no string interpolation)
  </done>
</task>

<task type="auto">
  <name>Task 2: Templates — history page, results partial, nav update</name>
  <files>
    fetcharr/templates/base.html
    fetcharr/templates/history.html
    fetcharr/templates/partials/history_results.html
  </files>
  <action>
**base.html — Add History nav link:**

Insert a "History" link between the Dashboard and Settings links in the nav bar. Add a new block for its active state styling:

```html
<a href="/"
   class="{% block nav_dashboard_class %}text-white{% endblock %} hover:text-white text-sm">
  Dashboard
</a>
<a href="/history"
   class="{% block nav_history_class %}text-fetcharr-muted{% endblock %} hover:text-white text-sm">
  History
</a>
<a href="/settings"
   class="{% block nav_settings_class %}text-fetcharr-muted{% endblock %} hover:text-white text-sm">
  Settings
</a>
```

**history.html — Full page template:**

Create `fetcharr/templates/history.html` extending base.html:
- Set title block: "Search History - Fetcharr"
- Set nav blocks: nav_dashboard_class = text-fetcharr-muted, nav_history_class = text-white, nav_settings_class = text-fetcharr-muted
- Content block contains:
  - `<h1 class="text-xl font-semibold mb-4">Search History</h1>`
  - A div that includes the history_results partial on initial load: `{% include "partials/history_results.html" %}`

**partials/history_results.html — Filter bar, results, pagination:**

Create `fetcharr/templates/partials/history_results.html`. This is the htmx-swappable partial. Structure:

```html
<div id="history-results">
```

**Filter bar section:**
- A flex-wrap container with filter groups.
- Each filter group: a label, then toggle pill buttons.
- App filter: "Radarr" pill, "Sonarr" pill. Each pill is an `<a>` tag styled as a pill button.
  - Active (in filter): `bg-orange-500/20 text-orange-400` for Radarr, `bg-blue-500/20 text-blue-400` for Sonarr
  - Inactive (filtered out): `bg-fetcharr-card text-fetcharr-muted border border-fetcharr-border`
- Queue type filter: "missing" pill, "cutoff" pill
  - Active: `bg-fetcharr-green/20 text-fetcharr-green`
  - Inactive: `bg-fetcharr-card text-fetcharr-muted border border-fetcharr-border`
- Outcome filter: "searched" pill, "failed" pill
  - Active for searched: `bg-fetcharr-green/20 text-fetcharr-green`
  - Active for failed: `bg-red-500/20 text-red-400`
  - Inactive: same as queue inactive
- Text search box: `<input type="search" name="search" placeholder="Search by title..." ...>` with Tailwind dark styling matching the project theme (`bg-fetcharr-bg border border-fetcharr-border text-fetcharr-text rounded px-3 py-1.5 text-sm`).

**htmx wiring for filters:**
- Each pill button uses `hx-get="/partials/history-results"` with `hx-target="#history-results"` and `hx-swap="outerHTML"`.
- The pill's href builds the query string: toggle the clicked filter value. If "Radarr" is currently active and user clicks it, remove it. If inactive, add it. Always reset page to 1 on filter change.
- Use Jinja2 to compute the toggled URL for each pill. The pattern: each pill link builds a URL with the current filter state minus/plus its own value.
- The text search input uses `hx-get="/partials/history-results"` with `hx-trigger="keyup changed delay:300ms"` and `hx-target="#history-results"` `hx-swap="outerHTML"`. Include current filter state as `hx-vals` or as hidden inputs in a wrapping form. Use `hx-include` to include the search input value. The simplest approach: wrap the search input in a form-like div and use hx-vals to pass current filter state as JSON: `hx-vals='{"app": "{{ active_apps|join(',') }}", "queue": "{{ active_queues|join(',') }}", "outcome": "{{ active_outcomes|join(',') }}"}'`.

**Results section:**
- "Showing X-Y of Z results" text above the table. Compute X = `(result.page - 1) * result.per_page + 1`, Y = `min(result.page * result.per_page, result.total)`. Display 0 of 0 if no results.
- Each entry row: same compact single-line format as dashboard search_log partial. Use the exact same styling:
  - Row number (entry id or sequential number)
  - App badge: `<span class="text-xs font-medium px-2 py-0.5 rounded {% if entry.app == 'Radarr' %}bg-orange-500/20 text-orange-400{% else %}bg-blue-500/20 text-blue-400{% endif %}">{{ entry.app }}</span>`
  - Item name: `<span class="text-sm flex-1 truncate">{{ entry.name }}</span>`
  - Queue type: `<span class="text-xs text-fetcharr-muted">{{ entry.queue_type }}</span>`
  - Outcome badge: `<span class="text-xs px-1.5 py-0.5 rounded {% if entry.outcome == 'failed' %}bg-red-500/20 text-red-400{% else %}bg-fetcharr-green/20 text-fetcharr-green{% endif %}">{{ entry.outcome or 'searched' }}</span>`
  - Timestamp: `<span class="text-xs text-fetcharr-muted">{{ entry.timestamp[:19] | replace('T', ' ') }}</span>`

**Empty state:**
- If `result.entries` is empty: `<p class="text-fetcharr-muted text-sm py-8 text-center">No search history yet. Searches will appear here after your first scheduled run.</p>`

**Pagination controls at bottom:**
- Only show if `result.total_pages > 1`.
- Flex container with centered items.
- "Previous" link: disabled style if page == 1, otherwise links to page - 1 with current filters.
- Page number links: show page numbers. For large page counts, show first, last, and window around current page with ellipsis. Use hx-get for all links with `hx-target="#history-results"` and `hx-swap="outerHTML"`.
- "Next" link: disabled style if page == total_pages.
- All pagination links carry the current filter state in their query params.
- Active page: `bg-fetcharr-green text-white` pill. Other pages: `bg-fetcharr-card text-fetcharr-muted border border-fetcharr-border hover:text-white`.

Closing `</div>` for `#history-results`.
  </action>
  <verify>
    <automated>cd /Users/julianamacbook/fetcharr && uv run python -c "
from jinja2 import Environment, FileSystemLoader
env = Environment(loader=FileSystemLoader('fetcharr/templates'))
for name in ['base.html', 'history.html', 'partials/history_results.html']:
    env.get_template(name)
print('all templates parse ok')
"</automated>
    <manual>Check that base.html has History link, history.html extends base, partial has filter pills and pagination</manual>
  </verify>
  <done>
    - base.html nav includes History link between Dashboard and Settings with active state block
    - history.html extends base.html with correct title and nav highlighting
    - history_results.html partial has filter pill buttons for all 3 filter groups + text search
    - Results rows match dashboard search_log styling (app badges, outcome badges, timestamps)
    - Pagination controls with prev/next and page numbers at bottom
    - Empty state message displayed when no entries
    - All filter/pagination interactions use htmx partial swaps
  </done>
</task>

</tasks>

<verification>
1. `uv run python -c "from fetcharr.db import get_search_history; print('ok')"` — import succeeds
2. `uv run python -c "from fetcharr.web.routes import history_page, partial_history_results; print('ok')"` — routes importable
3. Jinja2 template parsing succeeds for all 3 templates
4. `uv run ruff check fetcharr/db.py fetcharr/web/routes.py` — no lint errors
</verification>

<success_criteria>
- /history page accessible from nav bar, renders search history with filters and pagination
- Filter pills toggle and trigger htmx partial swaps (no full page reload)
- Pagination works with 50 entries per page, showing "Showing X-Y of Z results"
- Entry rows match dashboard search log styling
- Empty state displayed when no history exists
- All Python code passes ruff lint checks
</success_criteria>

<output>
After completion, create `.planning/phases/15-search-history-ui/15-01-SUMMARY.md`
</output>
